from math import inf       # імпортуємо значення нескінченності з модуля math
from copy import deepcopy  # імпортуємо deepcopy для копіювання вкладених списків

INF = inf  # зберігаємо нескінченність

# функція для редукції рядків матриці
def row_reduce(C_copy):
    n = len(C_copy)  # визначаємо розмір матриці (кількість рядків)

    for i in range(n): # цикл по всіх рядках
        vals = [C_copy[i][j] for j in range(n) if C_copy[i][j] != INF] # беремо всі значення в рядку, крім INF

        if not vals:  # якщо рядок повністю INF (нема що редукувати)
            continue  # пропускаємо цей рядок

        m = min(vals)  # знаходимо мінімальне значення в рядку
        if m != 0 and m != INF:  # якщо мінімум не 0 і рядок не викреслений

            for j in range(n):  # цикл по елементах рядка
                if C_copy[i][j] != INF:  # якщо елемент не INF
                    C_copy[i][j] -= m    # віднімаємо мінімум

    return C_copy  # повертаємо редуковану матрицю і суму редукції

# функція для редукції стовпців матриці
def col_reduce(C_copy):
    n = len(C_copy)  # визначаємо розмір матриці

    for j in range(n):  # цикл по всіх стовпцях
        vals = [C_copy[i][j] for i in range(n) if C_copy[i][j] != INF]  # беремо всі значення в стовпці, крім INF

        if not vals:  # якщо стовпець повністю INF
            continue  # пропускаємо

        m = min(vals)  # знаходимо мінімальне значення в стовпці
        if m != 0 and m != INF:  # якщо мінімум не 0 і стовпець не викреслений

            for i in range(n):  # цикл по елементах стовпця
                if C_copy[i][j] != INF:  # якщо елемент не INF
                    C_copy[i][j] -= m  # віднімаємо мінімум

    return C_copy  # повертаємо редуковану матрицю і суму редукції

# функція для обчислення оцінок для нульових клітинок
def zero_rating(C_copy):
    n = len(C_copy) # визначаємо розмір матриці
    result = []     # список, куди будемо складати всі оцінки нулів

    for i in range(n):     # цикл по рядках
        for j in range(n): # цикл по стовпцях

            if C_copy[i][j] == 0:  # якщо знайшли нульову клітинку
                row_vals = [C_copy[i][k] for k in range(n) if k != j and C_copy[i][k] != INF]  # всі значення в рядку i, крім стовпця j і INF
                col_vals = [C_copy[k][j] for k in range(n) if k != i and C_copy[k][j] != INF]  # всі значення в стовпці j, крім рядка i і INF

                r_min = min(row_vals) if row_vals else INF  # мінімум по рядку (якщо нічого нема то INF)
                c_min = min(col_vals) if col_vals else INF  # мінімум по стовпцю (якщо нічого нема то INF)

                marks = (0 if r_min == INF else r_min) + (0 if c_min == INF else c_min) # оцінка = мін по рядку + мін по стовпцю (INF рахуємо як 0)
                result.append((marks, i, j))  # додаємо (оцінку, координати нуля) в список

    return result  # повертаємо список усіх оцінок нульових клітин

# перевірка чи не створить ребро u->v підцикл
def cycle_check(next_map, prev_map, u, v, n):
    if u in next_map or v in prev_map:  # якщо з u вже є вихід або у v вже є вхід
        return True  # тоді додавати не можна

    cur = v    # стартуємо з вершини v
    steps = 0  # лічильник кроків по ланцюжку

    while cur in next_map:   # поки з поточної вершини є вихід
        cur = next_map[cur]  # переходимо в наступну вершину по вже вибраних дугах
        steps += 1  # збільшуємо кількість зроблених кроків

        if cur == u: # якщо ми повернулися в u
            return (steps + 1) < n  # якщо довжина циклу менша за n то це підцикл і він заборонений

        if steps > n:  # запобіжник, щоб не зациклитися
            return True  # якщо щось пішло не так то краще заборонити

    return False  # якщо до u не дійшли то підцикл не утворюється

# основна функція методу гілок і меж
def branches_and_borders(C):
    n = len(C)                          # зберігаємо розмір матриці

    if any(len(row) != n for row in C): # перевіряємо, чи матриця квадратна
        raise ValueError("\nПомилка! Матриця має бути квадратною") # якщо не квадратна то виводимо повідомлення про помилку

    C_copy = deepcopy(C) # створюємо копію матриці, щоб не зіпсувати оригінал

    # структури для маршруту
    next_map = {}  # словник виходів (next_map[u] = v означає: з міста u ми їдемо в місто v)
    prev_map = {}  # словник входів (prev_map[v] = u означає: у місто v ми приїхали з міста u)

    while len(next_map) < n:  # поки не вибрали n дуг (для повного циклу)
        C_copy = row_reduce(C_copy)  # редукуємо рядки
        C_copy = col_reduce(C_copy)  # редукуємо стовпці

        marks = zero_rating(C_copy) # рахуємо оцінки для всіх нульових клітинок
        if not marks: # якщо нульових клітин немає
            raise RuntimeError("\nПомилка! Немає нульових клітинок для вибору") # виведення відповідного повідомлення

        marks.sort(reverse=True, key=lambda x: x[0])  # сортуємо нулі за спаданням оцінки

        chosen = None  # змінна для вибраної дуги
        for mark, u, v in marks: # перебираємо кандидати від кращого до гіршого
            if cycle_check(next_map, prev_map, u, v, n):  # якщо додавання u до v створює підцикл або конфлікт
                continue  # пропускаємо цього кандидата

            if C_copy[u][v] == INF:  # якщо ця дуга нескінченна
                continue  # пропускаємо цього кандидата

            chosen = (mark, u, v)  # якщо знайшли нормального кандидата то фіксуємо
            break  # виходимо з циклу

        if chosen is None:  # якщо жоден кандидат не підійшов
            raise RuntimeError("\nПомилка! Усі кандидати ведуть до підциклу/конфлікту") # виведення повідомлення про помилку

        mark, u, v = chosen  # розпаковуємо вибрану дугу
        print(f"На кроці {len(next_map) + 1} обрано маршрут з {u + 1} до {v + 1} з оцінкою {mark}") # виводимо, що вибрали (1..n)

        next_map[u] = v  # записуємо вихід з u у v
        prev_map[v] = u  # записуємо вхід у v з u

        C_copy[v][u] = INF  # забороняємо зворотню дугу v - u (щоб не утворився 2-цикл)

        for j in range(n):      # цикл по стовпцях
            C_copy[u][j] = INF  # викреслюємо весь рядок u (інші виходи з u вже не можна)

        for i in range(n):      # цикл по рядках
            C_copy[i][v] = INF  # викреслюємо весь стовпець v (інші входи у v вже не можна)

        for i in range(n):      # цикл по діагоналі
            C_copy[i][i] = INF  # забороняємо переходи з i до i

    # відновлення маршруту
    start = 0       # стартове місто (0 = місто 1)
    way = [start] # список маршруту, починаємо зі старту
    cur = start   # поточне місто
    for _ in range(n - 1):  # потрібно додати ще n-1 міст
        cur = next_map[cur] # переходимо в наступне місто по знайдених дугах
        way.append(cur)     # додаємо його в маршрут

    length = 0.0       # змінна для підрахунку довжини маршруту
    for i in range(n): # проходимо по всіх ребрах маршруту
        a = way[i]           # поточне місто
        b = way[(i + 1) % n] # наступне місто (останнє з’єднується з першим)
        w = C[a][b]          # беремо вагу ребра з початкової матриці

        if w == INF:         # якщо раптом попали на заборонений шлях
            raise RuntimeError("\nПомилка! У фінальному маршруті є заборонена дуга") # виведення повідомлення про помилку

        length += w    # додаємо вагу до загальної довжини

    return way, length # повертаємо маршрут і його довжину


def print_matrix(C):   # функція для красивого друку матриці
    n = len(C)         # розмір матриці
    for i in range(n): # цикл по рядках
        row = []       # тимчасовий список для рядка
        for j in range(n):      # цикл по стовпцях
            if C[i][j] == INF:  # якщо нескінченність
                row.append("∞") # додаємо символ нескінченності
            else:               # якщо не нескінченність
                row.append(str(int(C[i][j]))) # інакше додаємо число як рядок

        print("| " + " ".join(f"{x:>3}" for x in row) + " |") # друкуємо рядок у таблиці


def main(): # головна функція програми
    # задана матриця вартостей
    C = [
        [INF, 15, 18, 14, 15, 17],
        [17, INF, 16,  9, 19, 10],
        [11, 19, INF, 15, 13, 16],
        [18, 20, 11, INF, 19, 15],
        [11, 10,  9, 18, INF, 18],
        [14, 12,  9, 13, 16, INF],
    ]

    # виведення вхідної матриці
    print("Вхідна матриця вартостей:")
    print_matrix(C) # друк матриці
    print()         # порожній рядок

    way, length = branches_and_borders(C)  # викликаємо алгоритм і отримуємо маршрут та довжину

    # виведення результатів
    way_str = " -> ".join(str(x + 1) for x in way) + f" -> {way[0] + 1}"
    print("\nОтриманий маршрут:", way_str)
    print("Довжина даного маршруту:", length)

main() # викликаємо головну функцію програми
