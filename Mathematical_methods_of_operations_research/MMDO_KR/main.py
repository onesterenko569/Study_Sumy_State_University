

# МЕТОД ДИНАМІЧНОГО ПРОГРАМУВАННЯ


# функція методу динамічного програмування
def dynamic_programming(n, total_invest, invest_values, profit, col_width):
    print("\n____________________ ПОЧАТОК РОЗРАХУНКУ ____________________")  # виведення заголовка етапу

    optimal_strategies = {}  # словник для збереження результатів (optimal_strategies[k] = {C: (max_val, best_x)})
    prev_F = {}  # зберігатиме результат попереднього розрахованого кроку

    for k in range(n, 0, -1):  # цикл від останнього підприємства до першого (крок -1)
        print(f"\n{n - k + 1}-й крок: k = {k}")  # виведення номера кроку та поточного підприємства

        current_strategy = {}  # словник для збереження результатів поточного етапу k

        # налаштування вигляду таблиці
        res_col_width = 10  # задаємо ширину колонки для результатів у таблиці

        # рахуємо загальну довжину лінії (ширина таблиці)
        table_width = (col_width + 1) + (res_col_width + 1) * len(invest_values) + (col_width + 1) * 2 + 1

        h_line = "-" * table_width  # створюємо горизонтальну суцільну лінію
        print(h_line)  # друкуємо верхню лінію таблиці

        header = f"|{'C \\ X':^{col_width}}|"  # формуємо початок заголовка (перша колонка)

        for x in invest_values:  # цикл для додавання колонок з можливими x
            header += f"{x:^{res_col_width}}|"  # додаємо x (к-сть інвестицій) до заголовка

        header += f"{f'F{k}(C{k})':^{col_width}}|"  # додаємо колонку максимального прибутку
        header += f"{f'd{k}':^{col_width}}|"  # додаємо колонку оптимального рішення

        print(header)  # друкуємо сформований заголовок
        print(h_line)  # друкуємо розділювальну лінію

        for C in invest_values:  # перебираємо всі можливі варіанти ресурсів (С = 0, 20, ..., 100)
            row_str = f"|{C:^{col_width}}|"  # починаємо формування рядка з значення C

            max_val = -1.0  # зберігатиме найкращий знайдений прибуток для інвестиції C
            best_x = -1  # зберігатиме об'єм інвестиції яку треба дати підприємству k, щоб отримати найкраший прибуток

            for x in invest_values:  # внутрішній цикл перебору варіантів інвестицій x

                is_valid = True  # прапорець можливості варіанту (спочатку вважаємо, що варіант можливий)

                if x > C:  # якщо сума інвестиції більша за наявний ресурс
                    is_valid = False  # позначаємо варіант як недопустимий

                if k == n and x != C:  # якщо це останнє підприємство і ми витрачаємо не все C
                    is_valid = False  # позначаємо варіант як недопустимий

                if not is_valid:  # якщо варіант неможливий - ставимо прочерк
                    row_str += f"{'-':^{res_col_width}}|"  # додаємо прочерк у рядок
                    continue  # переходимо до наступної ітерації (наступного x)

                current_profit = profit[x][k - 1]  # беремо прибуток поточного k підприємства при х інвестиції

                if k == n:  # якщо це останнє підприємство
                    total_profit = current_profit  # повний прибуток дорівнює поточному (бо використовуємо всі кошти)
                    val_str = f"{total_profit:.1f}"  # формуємо рядок просто як число

                else:  # для всіх інших підприємств
                    remainder = C - x  # скільки грошей залишиться наступним підприємствам
                    prev_profit = prev_F[remainder][0]  # беремо прибуток від наступного підприємства з попереднього кроку
                    total_profit = current_profit + prev_profit  # обраховуємо повний прибуток

                    val_str = f"{current_profit:.1f}+{prev_profit:.1f}"  # формуємо рядок у форматі суми

                row_str += f"{val_str:^{res_col_width}}|"  # додаємо відформатоване значення у рядок таблиці

                if total_profit >= max_val:  # якщо поточний прибуток більший або рівний максимальному
                    max_val = total_profit  # запам'ятовуємо новий найбільший прибуток
                    best_x = x  # зберігаємо к-сть інвестицій для k-того підприємства яку треба дати, щоб отримати найкраший прибуток

            # дописуємо результати в кінець рядка
            row_str += f"{max_val:^{col_width}.1f}|"  # додаємо значення для колонки максимального прибутку
            row_str += f"{best_x:^{col_width}}|"  # додаємо значення для колонки оптимального рішення
            print(row_str)  # виводимо готовий рядок таблиці на екран

            current_strategy[C] = (max_val,
                                   best_x)  # запам'ятовуємо найкращий прибуток та рішення для ресурсу C у словник

        print(h_line)  # друкуємо нижню лінію таблиці

        # оновлюємо дані для наступного кроку
        prev_F = current_strategy  # поточна стратегія стає попередньою для наступного кроку циклу
        optimal_strategies[k] = current_strategy  # зберігаємо повну стратегію етапу в загальний словник

    print("\n____________________ РЕЗУЛЬТАТ РОЗРАХУНКУ ____________________")  # виведення заголовка другого етапу

    max_total_profit = optimal_strategies[1][total_invest][0]  # знаходимо глобальний максимум прибутку (з результатів 1-го підприємства)

    remaining_cash = total_invest  # змінна для відстеження залишку грошей (починаємо з повної суми)

    for k in range(1, n + 1):  # проходимо по кожному підприємству
        best_invest = optimal_strategies[k][remaining_cash][1]  # дістаємо к-сть інвестицій для k-того підприємства яку треба дати, щоб отримати найкраший прибуток
        current_profit = profit[best_invest][k - 1]  # знаходимо конкретний прибуток для цього підприємства

        print(f"Підприємство {k}: виділяємо {best_invest} ум. од. ресурсів, отримуємо {current_profit:.1f} од. товару")  # виводимо інформацію про розподіл для поточного підприємства
        remaining_cash -= best_invest  # зменшуємо доступний бюджет на витрачену суму

    print(f"\nЗагальний приріст випуску продукції: {max_total_profit:.2f} ум. од. продукції")  # виводимо максимальний дохід


# МЕТОД ГІЛОК ТА МЕЖ


# рахує, скільки максимум прибутку можна отримати від підприємств, починаючи з i-го до кінця
def max_potential_profit(profit_data):
    n = len(profit_data)                           # визначаємо кількість підприємств
    max_profit = [max(row) for row in profit_data] # знаходимо максимальний можливий прибуток для кожного підприємства

    potential_profit = [0] * (n + 1) # створюємо список потенційного прибутку

    for i in range(n - 1, -1, -1): # проходимо по підприємствах у зворотному порядку
        potential_profit[i] = potential_profit[i + 1] + max_profit[i] # накопичуємо суму максимумів від поточного до останнього підприємства

    return potential_profit # повертаємо список потенційних максимальних прибутків


# рекурсивна функція реалізації методу гілок та меж
def branch_and_bounds_solution(factory_idx, used_money, current_profit, current_investment_plan, profit_data, invest_values, total_invest, potential_profit, record, n):
    # умова зупинки (якщо розглянули всі підприємства)
    if factory_idx == n: # якщо розглянули всі підприємства
        if used_money == total_invest: # якщо використали весь бюджет повністю
            if current_profit > record["max_profit"]: # якщо поточний прибуток більший за знайдений раніше рекорд
                record["max_profit"] = current_profit # оновлюємо значення максимального прибутку
                record["investment_plan"] = list(current_investment_plan) # зберігаємо поточний варіант розподілу коштів

                # друк проміжних результатів
                print("\nЗнайдено кращий варіант:")

                for i, money in enumerate(record['investment_plan']):  # виводимо деталізацію по кожному підприємству
                    idx_C = invest_values.index(money)  # знаходимо індекс суми в списку варіантів
                    profit = profit_data[i][idx_C]  # знаходимо відповідний прибуток для підприємства
                    print(f"   {i + 1} підприємство: вкладаємо {money} ум. од. ресурсів, отримуємо {profit} од. товару")

                print(f"\n   Загальний приріст випуску продукції: {record['max_profit']}")

        return # виходимо з рекурсії (повертаємося назад)

    # відсікання (перевірка перспективності гілки)
    potential_remaining = potential_profit[factory_idx] # дізнаємося, скільки макс. прибутку можна ще отримати з підприємств, що лишилися
    if current_profit + potential_remaining <= record["max_profit"]: # якщо навіть ідеальний розклад не поб'є рекорд
        return # відсікаємо цю гілку (не перевіряємо далі)

    # розгалуження (задачу розбиваємо на підзадачі), перебір варіантів
    for x in sorted(invest_values, reverse=True): # перебираємо варіанти інвестицій від найбільшого до найменшого
        if used_money + x <= total_invest:        # перевіряємо, чи не перевищуємо ми ліміт бюджету

            idx_in_row = invest_values.index(x)   # знаходимо індекс стовпця для поточної суми інвестицій
            profit_from_x = profit_data[factory_idx][idx_in_row] # отримуємо значення прибутку для поточного підприємства

            current_investment_plan.append(x)     # додаємо поточну суму в список розподілу

            # рекурсивний виклик для наступного підприємства (заглиблюємося в дерево)
            branch_and_bounds_solution(factory_idx + 1,                                   # переходимо до наступного підприємства
                   used_money + x,                                                        # оновлюємо використаний бюджет
                   current_profit + profit_from_x,                                        # оновлюємо накопичений прибуток
                   current_investment_plan,                                               # передаємо поточний список розподілу коштів між підприємствами
                   profit_data, invest_values, total_invest, potential_profit, record, n) # передаємо допоміжні дані

            current_investment_plan.pop()  # крок назад (видаляємо останній елемент, щоб спробувати іншу суму)

# функція-запуск (готує дані і викликає рекурсивну функцію яка обраховує методом гілок та меж)
def preparation_branch_and_bound(profit_data, invest_values, total_invest):
    n = len(profit_data)                                 # визначаємо загальну кількість підприємств
    potential_profit = max_potential_profit(profit_data) # розраховуємо потенційні прибутки від підприємств, починаючи з i-го до кінця

    # словник для збереження найкращого результату та відповідного розподілу коштів, щоб отримати найкращий результат
    record = \
    {
        "max_profit": -1.0,   # зберігатиме найкращий результат прибутку
        "investment_plan": [] # список найкращого розподілу коштів ([20, 40, 40, 0] - 1-му дали 20, 2-му — 40, 3-му — 40, 4-му — 0)
    }

    print("\n____________________ ПОЧАТОК РОЗРАХУНКУ ____________________")
    # викликаємо рекурсивну функцію з початковими параметрами
    branch_and_bounds_solution(0, 0, 0, [], profit_data, invest_values, total_invest, potential_profit, record, n)

    # повертаємо найкращий знайдений розподіл та прибуток
    return record["investment_plan"], record["max_profit"]

# функція перетворює початковий дані зі словника у двовимірний масив та запускає процес обчислення методом гілок та меж
def converting_dictionary_to_list(n, total_invest, invest_values, profit):
    # створюємо порожній список, який стане нашою головною таблицею даних
    profit_data = []  # список для матриці прибутків (формат для алгоритму)

    for i in range(n):  # цикл по рядках підприємствах
        factory_row = []  # рядок для конкретного і-того підприємства

        for x in invest_values:  # цикл по інвестиціях
            factory_row.append(profit[x][i])  # беремо прибуток i-го підприємства для суми x

        profit_data.append(factory_row)  # додаємо рядок прибутків для i-го підприємства у головну матрицю

    # викликаємо функцію розрахунку методом гілок та меж
    investment_plan, max_profit = preparation_branch_and_bound(profit_data, invest_values, total_invest)

    # виведення результатів
    print("\n____________________ РЕЗУЛЬТАТ РОЗРАХУНКУ ____________________")
    if investment_plan:  # якщо розв'язок знайдено
        for i, money in enumerate(investment_plan):  # виводимо деталізацію по кожному підприємству
            idx_C = invest_values.index(money)  # знаходимо індекс суми в списку варіантів
            profit = profit_data[i][idx_C]  # знаходимо відповідний прибуток для підприємства
            print(f"Підприємство {i + 1}: виділяємо {money} ум. од. ресурсів, отримуємо {profit} од. товару")

        print(
            f"\nЗагальний приріст випуску продукції: {max_profit:.2f} ум. од. продукції")  # виводимо фінальний результат
    else:
        print("На жаль, розв'язок не знайдено")  # повідомлення, якщо алгоритм не знайшов розв'язок


# ГОЛОВНА ФУНКЦІЯ ПРОГРАМИ
def main():
    print("______________ ВВЕДЕННЯ ДАНИХ ______________")

    print("\nКількість підприємств")
    while True: # введення кількості підприємств
        try:    # спробуємо виконати наступний блок коду
            n = int(input("   Введіть кількість підприємств: "))            # користувач вводить кількість підприємств
            if n < 2:                                                       # якщо кількість підприємств менша за 2
                print("   Кількість підприємств має бути більшою за 1!")    # виведення повідомлення про помилку
                continue                                                    # розпочинаємо цикл спочатку
            elif n > 100:                                                   # якщо кількість підприємств більша за 100
                print("   Кількість підприємств має бути меншою за 100!")   # виведення повідомлення про помилку
                continue                                                    # розпочинаємо цикл спочатку
            else:                                                           # якщо все введено правильно
                break                                                       # зупиняємо цикл

        except ValueError:                                                  # якщо виникла помилка при перетворенні на int
            print("   Помилка! Введіть ціле число")                         # виведення повідомлення про помилку
            continue                                                        # розпочинаємо цикл спочатку

    print("\nЗагальна кількість ресурсів")
    while True: # введення загальної кількості ресурсів
        try:    # спробуємо виконати наступний блок коду
            total_invest = int(input("   Введіть загальну кількість ресурсів: ")) # користувач вводить кількість ресурсів
            if total_invest <= 0:                                           # якщо кількість ресурсів менша або дорівнює 0
                print("   Кількість ресурсів має бути більшою за 0!")       # виведення повідомлення про помилку
                continue                                                    # розпочинаємо цикл спочатку
            else:                                                           # якщо все введено правильно
                break                                                       # зупиняємо цикл

        except ValueError:                                                  # якщо виникла помилка при перетворенні на int
            print("   Помилка! Введіть ціле число")                         # виведення повідомлення про помилку
            continue                                                        # розпочинаємо цикл спочатку

    print("\nКрок розподілу ресурсів")
    while True:  # введення кроку розподілу ресурсів
        try:     # спробуємо виконати наступний блок коду
            step = int(input("   Введіть крок розподілу ресурсів: "))       # користувач вводить крок розподілу ресурсів
            if step <= 0:                                                   # якщо крок менший або дорівнює 0
                print("   Крок розподілу ресурсів повинен бути більшим за 0!") # виведення повідомлення про помилку
                continue                                                    # розпочинаємо цикл спочатку
            elif step > total_invest:                                       # якщо крок більший за загальну суму ресурсів
                print("   Крок розподілу ресурсів не повинен бути більшим за загальну кількість ресурсів!") # виведення повідомлення про помилку
                continue                                                    # розпочинаємо цикл спочатку
            else:                                                           # якщо все введено правильно
                break                                                       # зупиняємо цикл

        except ValueError:                                                  # якщо виникла помилка при перетворенні на int
            print("   Помилка! Введіть ціле число")                         # виведення повідомлення про помилку
            continue                                                        # розпочинаємо цикл спочатку

    # створюємо список значень інвестицій від 0 до total_invest з кроком step
    invest_values = list(range(0, total_invest + 1, step))

    # структура для зберігання прибутків (словник, де ключ = сума інвестицій profits[x] = [g1(x), g2(x), g3(x), g4(x)])
    profit = {}

    # автоматично заповнюємо для 0 інвестицій (прибуток 0)
    profit[0] = [0.0] * n

    print("\nВведення прибутків для кожного підприємства", end = "")
    for x in invest_values: # цикл введення даних для кожної інвестиції
        if x == 0:                                       # якщо інвестиції в розмірі 0 ум. од
            continue                                     # переходимо до наступної ітерації циклу

        print(f"\n   Введіть приріст випуску продукції для капіталовкладень обсягом {x} ум. одиниць:")
        row_values = []     # список для зберігання прибутків для кожного підприємства

        for i in range(1, n + 1): # цикл по кожному підприємству
            while True: # цикл триватиме до моменту, коли користувач правильно введе прибуток
                try:    # спробуємо виконати наступний блок коду
                    val_str = input(f"      Підприємство {i}: ")       # вводимо прибуток для і-того підприємства
                    val = float(val_str)                               # перетворюємо з str у float

                    if val < 0:                                        # перевірка на коректність введення
                        print("      Прибуток не може бути від'ємним!")# виведення відповідного повідомлення
                        continue                                       # розпочинаємо цикл спочатку
                    else:                                              # якщо користувач правильно ввів
                        row_values.append(val)                         # додаємо значення до списку
                        break                                          # завершуємо цикл

                except ValueError:                                     # якщо виникла помилка при перетворенні str на float
                    print("      Помилка! Введіть число")              # виведення відповідного повідомлення

        profit[x] = row_values                                         # додаємо введені прибутки до словника

    # виведення таблиці
    print("\nТаблиця введених даних:")

    col_width = 7                               # задаємо ширину колонці
    total_width = (col_width + 1) * (n + 1) + 1 # рахуємо довжину лінії (ширина таблиці)
    horizontal_line = "-" * total_width         # створюємо горизонтальну суцільну лінію

    print(horizontal_line)                      # друкуємо вверх таблиці

    # формування заголовка
    header_row = f"|{'X':^{col_width}}|"          # записуємо х по середині клітинки

    for i in range(1, n + 1):                     # цикл по підприємствах
        header_row += f"{f'g{i}':^{col_width}}|"  # додаємо до заголовку відцентровані клітинки

    print(header_row)                             # друкуємо клітинки
    print(horizontal_line)                        # друкуємо горизонтальну лінію

    # формування рядків з даними
    for x in invest_values:                       # проходимося по кожному інвестиційному значенні
        row_str = f"|{x:^{col_width}}|"           # додаємо значення х та відцентровуємо значення

        for val in profit[x]:                     # цикл по прибутках підприємств для х інвестицій
            row_str += f"{val:^{col_width}.1f}|"  # додаємо g(x) відцентроване посередині

        print(row_str)                            # друкуємо рядок таблиці

    print(horizontal_line)                        # друкуємо горизонтальну лінію

    # реалізація вибору методу для користувача
    while True: # цикл виконується поки не спрацює break
        # меню для користувача
        print("\nОберіть метод розв'язання задачі:")
        print("1 – Метод динамічного програмування")
        print("2 – Метод гілок та меж")
        print("0 – Вийти з програми")

        # ініціалізуємо змінну, яка зберігатиме вибір користувача
        user_choice = 0

        while True: # цикл виконується поки не спрацює break
            try:    # спробуємо виконати наступний блок коду
                user_choice = int(input("\nВаш вибір: ")) # користувач вводить вибір

                if user_choice in (0, 1, 2): # якщо введено правильно
                    break                    # завершуємо цикл

                else: # якщо введено не правильно
                    print("Помилка! Допустимі значення: 0, 1 або 2\nСпробуйте знову") # відповідне повідомлення
                    continue # розпочинаємо наступну ітерацію

            except ValueError:                         # якщо виникла помилка при перетворенні на int
                print("Помилка! Введіть ціле число")   # виведення повідомлення про помилку
                continue                               # розпочинаємо цикл спочатку

        if user_choice == 0: # якщо введено 0
            break            # завершуємо програму

        elif user_choice == 1: # якщо введено 1
            print("\n          РОЗВ'ЯЗОК МЕТОДОМ ДИНАМІЧНОГО ПРОГРАМУВАННЯ")

            # викликаємо функцію методу динамічного програмування
            dynamic_programming(n, total_invest, invest_values, profit, col_width)

        else: # якщо введено 2
            print("\n                     МЕТОД ГІЛОК ТА МЕЖ")

            # викликаємо функцію методу гілок та меж
            converting_dictionary_to_list(n, total_invest, invest_values, profit)


main() # виклик головної функції програми


