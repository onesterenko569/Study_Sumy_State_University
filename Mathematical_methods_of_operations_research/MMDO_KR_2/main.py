import sys


# ==========================================
# 1. ФУНКЦІЇ МЕТОДУ ГІЛОК ТА МЕЖ
# ==========================================



# рахує, скільки максимум прибутку можна отримати від підприємств, починаючи з i-го до кінця
def max_potential_profit(profit_data):
    n = len(profit_data)                           # визначаємо кількість підприємств
    max_profit = [max(row) for row in profit_data] # знаходимо максимальний можливий прибуток для кожного підприємства

    potential_profit = [0] * (n + 1) # створюємо список потенційного прибутку

    for i in range(n - 1, -1, -1): # проходимо по підприємствах у зворотному порядку
        potential_profit[i] = potential_profit[i + 1] + max_profit[i] # накопичуємо суму максимумів від поточного до останнього підприємства

    return potential_profit # повертаємо список потенційних максимальних прибутків


# рекурсивна функція реалізації методу гілок та меж
def branch_and_bounds_solution(factory_idx, used_money, current_profit, current_investment_plan, profit_data, invest_values, total_invest, potential_profit, record, n):
    # умова зупинки (якщо розглянули всі підприємства)
    if factory_idx == n: # якщо розглянули всі підприємства
        if used_money == total_invest: # якщо використали весь бюджет повністю
            if current_profit > record["max_profit"]: # якщо поточний прибуток більший за знайдений раніше рекорд
                record["max_profit"] = current_profit # оновлюємо значення максимального прибутку
                record["investment_plan"] = list(current_investment_plan) # зберігаємо поточний варіант розподілу коштів

                # друк проміжних результатів
                print("\nЗнайдено кращий варіант:")

                for i, money in enumerate(record['investment_plan']):  # виводимо деталізацію по кожному підприємству
                    idx_C = invest_values.index(money)  # знаходимо індекс суми в списку варіантів
                    profit = profit_data[i][idx_C]  # знаходимо відповідний прибуток для підприємства
                    print(f"   {i + 1} підприємство: вкладаємо {money} ум. од. ресурсів, отримуємо {profit} од. товару")

                print(f"\n   Загальний приріст випуску продукції: {record['max_profit']}")

        return # виходимо з рекурсії (повертаємося назад)

    # відсікання (перевірка перспективності гілки)
    potential_remaining = potential_profit[factory_idx] # дізнаємося, скільки макс. прибутку можна ще отримати з підприємств, що лишилися
    if current_profit + potential_remaining <= record["max_profit"]: # якщо навіть ідеальний розклад не поб'є рекорд
        return # відсікаємо цю гілку (не перевіряємо далі)

    # розгалуження (задачу розбиваємо на підзадачі), перебір варіантів
    for x in sorted(invest_values, reverse=True): # перебираємо варіанти інвестицій від найбільшого до найменшого
        if used_money + x <= total_invest:        # перевіряємо, чи не перевищуємо ми ліміт бюджету

            idx_in_row = invest_values.index(x)   # знаходимо індекс стовпця для поточної суми інвестицій
            profit_from_x = profit_data[factory_idx][idx_in_row] # отримуємо значення прибутку для поточного підприємства

            current_investment_plan.append(x)     # додаємо поточну суму в список розподілу

            # рекурсивний виклик для наступного підприємства (заглиблюємося в дерево)
            branch_and_bounds_solution(factory_idx + 1,                                   # переходимо до наступного підприємства
                   used_money + x,                                                        # оновлюємо використаний бюджет
                   current_profit + profit_from_x,                                        # оновлюємо накопичений прибуток
                   current_investment_plan,                                               # передаємо поточний список розподілу коштів між підприємствами
                   profit_data, invest_values, total_invest, potential_profit, record, n) # передаємо допоміжні дані

            current_investment_plan.pop()  # крок назад (видаляємо останній елемент, щоб спробувати іншу суму)

# функція-запуск (готує дані і викликає рекурсивну функцію яка обраховує методом гілок та меж)
def preparation_branch_and_bound(profit_data, invest_values, total_invest):
    n = len(profit_data)                                 # визначаємо загальну кількість підприємств
    potential_profit = max_potential_profit(profit_data) # розраховуємо потенційні прибутки від підприємств, починаючи з i-го до кінця

    # словник для збереження найкращого результату та відповідного розподілу коштів, щоб отримати найкращий результат
    record = \
    {
        "max_profit": -1.0,   # зберігатиме найкращий результат прибутку
        "investment_plan": [] # список найкращого розподілу коштів ([20, 40, 40, 0] - 1-му дали 20, 2-му — 40, 3-му — 40, 4-му — 0)
    }

    print("\n____________________ ПОЧАТОК РОЗРАХУНКУ ____________________")
    # викликаємо рекурсивну функцію з початковими параметрами
    branch_and_bounds_solution(0, 0, 0, [], profit_data, invest_values, total_invest, potential_profit, record, n)

    # повертаємо найкращий знайдений розподіл та прибуток
    return record["investment_plan"], record["max_profit"]


# ==========================================
# 2. ГОЛОВНА ФУНКЦІЯ (ВВЕДЕННЯ ТА ВИВІД)
# ==========================================
def main():
    print("____________________ ВВЕДЕННЯ ДАНИХ ____________________")

    print("\nКількість підприємств")
    while True: # цикл перевірки введення кількості підприємств
        try:
            n = int(input("   Введіть кількість підприємств: "))  # користувач вводить кількість підприємств
            if n < 2:  # якщо кількість підприємств менша за 2
                print("   Кількість підприємств має бути більшою за 1!")
                continue  # розпочинаємо цикл спочатку
            elif n > 100:  # якщо кількість занадто велика
                print("   Кількість підприємств має бути меншою за 100!")
                continue  # розпочинаємо цикл спочатку
            else:  # якщо все введено правильно
                break  # зупиняємо цикл
        except ValueError:  # якщо виникла помилка типу даних
            print("   Помилка! Введіть ціле число")
            continue

    print("\nЗагальна кількість ресурсів")
    while True:  # цикл перевірки введення бюджету
        try:
            total_invest = int(input("   Введіть загальну кількість ресурсів: "))
            if total_invest <= 0:  # якщо ресурси менші або дорівнюють 0
                print("   Кількість ресурсів має бути більшою за 0!")
                continue
            else:
                break
        except ValueError:
            print("   Помилка! Введіть ціле число")
            continue

    print("\nКрок розподілу ресурсів")
    while True:  # цикл перевірки введення кроку
        try:
            step = int(input("   Введіть крок розподілу ресурсів: "))
            if step <= 0:  # якщо крок некоректний
                print("   Крок розподілу ресурсів повинен бути більшим за 0!")
                continue
            elif step > total_invest:  # якщо крок більший за бюджет
                print("   Крок розподілу ресурсів не повинен бути більшим за загальну кількість ресурсів!")
                continue
            else:
                break
        except ValueError:
            print("   Помилка! Введіть ціле число")
            continue

            # створюємо список значень інвестицій від 0 до total_invest
    invest_values = list(range(0, total_invest + 1, step))

    profit = {}  # словник для зберігання введених даних
    profit[0] = [0.0] * n  # автоматично заповнюємо для 0 інвестицій (прибуток 0)

    print("\nВведення прибутків для кожного підприємства", end="")
    for x in invest_values:  # цикл по кожній сумі інвестицій
        if x == 0:  # пропускаємо 0, бо вже заповнили
            continue

        print(f"\n   Введіть приріст випуску продукції для капіталовкладень обсягом {x} ум. одиниць:")
        row_values = []  # тимчасовий список для поточного кроку

        for i in range(1, n + 1):  # цикл по кожному підприємству
            while True:
                try:
                    val_str = input(f"      Підприємство {i}: ")  # вводимо прибуток
                    val = float(val_str)  # конвертуємо у число з плаваючою крапкою

                    if val < 0:  # перевірка на від'ємність
                        print("      Прибуток не може бути від'ємним!")
                        continue
                    else:  # якщо все ок
                        row_values.append(val)  # додаємо значення
                        break
                except ValueError:
                    print("      Помилка! Введіть число")

        profit[x] = row_values  # записуємо список у словник під ключем x

    # Виведення таблиці для перевірки
    print("\nТаблиця введених даних:")
    col_width = 7  # ширина колонки
    total_width = (col_width + 1) * (n + 1) + 1  # загальна ширина таблиці
    horizontal_line = "-" * total_width  # розділова лінія

    print(horizontal_line)
    header_row = f"|{'X':^{col_width}}|"  # заголовок першої колонки
    for i in range(1, n + 1):
        header_row += f"{f'g{i}':^{col_width}}|"  # додаємо заголовки підприємств
    print(header_row)
    print(horizontal_line)

    for x in invest_values:  # виводимо рядки таблиці
        row_str = f"|{x:^{col_width}}|"
        for val in profit[x]:
            row_str += f"{val:^{col_width}.1f}|"  # форматуємо числа
        print(row_str)
    print(horizontal_line)

    # =================================================================
    # ПІДГОТОВКА ДАНИХ (КОНВЕРТАЦІЯ)
    # =================================================================


    # створюємо порожній список, який стане нашою головною таблицею даних
    profit_data = []  # список для матриці прибутків (формат для алгоритму)

    for i in range(n):     # цикл по рядках підприємствах
        factory_row = []   # рядок для конкретного і-того підприємства

        for x in invest_values:               # цикл по інвестиціях
            factory_row.append(profit[x][i])  # беремо прибуток i-го підприємства для суми x

        profit_data.append(factory_row)  # додаємо рядок прибутків для i-го підприємства у головну матрицю

    # викликаємо функцію розрахунку методом гілок та меж
    investment_plan, max_profit = preparation_branch_and_bound(profit_data, invest_values, total_invest)

    print("\n____________________ РЕЗУЛЬТАТ РОЗРАХУНКУ ____________________")
    if investment_plan: # якщо розв'язок знайдено
        for i, money in enumerate(investment_plan): # виводимо деталізацію по кожному підприємству
            idx_C = invest_values.index(money)      # знаходимо індекс суми в списку варіантів
            profit = profit_data[i][idx_C]          # знаходимо відповідний прибуток для підприємства
            print(f"Підприємство {i + 1}: виділяємо {money} ум. од. ресурсів, отримуємо {profit} од. товару")

        print(f"\nЗагальний приріст випуску продукції: {max_profit:.2f} ум. од. продукції") # виводимо фінальний результат
    else:
        print("На жаль, розв'язок не знайдено") # повідомлення, якщо алгоритм не знайшов розв'язок

main()  # запуск головної функції