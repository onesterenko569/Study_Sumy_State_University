import sympy as sp  # підключаємо модуль для символьних обчислень
import math  # підключаємо модуль для математичних операцій (корінь тощо)


def main():  # головна функція програми
    print("\n____ЗНАХОДЖЕННЯ ТОЧКИ МАКСИМУМУ МЕТОДОМ НЕЛДЕРА-МІДА____\n")

    # введення функції користувачем
    x, y = sp.symbols('x y')  # створюємо символічні змінні x та y
    while True:  # цикл працює поки не виконається break
        user_function = input("Введіть функцію f(x, y): ")  # користувач вводить функцію

        try:  # спробуємо виконати наступний блок коду
            f = sp.sympify(user_function)  # перетворюємо текст у математичний вираз
        except (sp.SympifyError, SyntaxError):  # якщо виникла помилка при перетворенні тексту в мат. вираз
            print("Помилка! Введено некоректну функцію. Спробуйте ще раз.")  # виведення відповідного повідомлення
            continue  # переходимо до наступної ітерації циклу

        if not f.has(x) and not f.has(y):  # якщо у введеній функції немає x або y
            print("Функція повинна містити x або y!")  # виведення відповідного повідомлення
            continue  # переходимо до наступної ітерації циклу

        break  # зупиняємо цикл, якщо функцію було вірно введено

    # Створюємо швидку функцію для обчислень (щоб не використовувати subs щоразу)
    fun = sp.lambdify((x, y), -f, 'math')  # конвертуємо символьний вираз у функцію Python

    print("Функція успішно введена!")  # виведення повідомлення про успіх

    # введення початкової точки
    print("\nВведіть координати початкової точки:")
    while True:  # цикл працює поки не виконається break
        x_str = input("x = ")  # вводимо х
        y_str = input("y = ")  # вводимо у

        try:  # спробуємо перетворити х та у з str у float
            x_val = float(x_str)
            y_val = float(y_str)
        except ValueError:  # якщо виникла помилка при перетворенні
            print("Помилка при введенні координат! Спробуйте знову")  # виведення відповідного повідомлення
            continue  # починає наступну ітерацію циклу

        break  # зупиняє цикл, якщо координати точки було введено правильно

    # введення точності
    while True:  # цикл працює поки не виконається break
        e_str = input("\nВведіть точність обчислень: ")  # вводимо точність обчислень

        try:  # спробуємо перетворити е з str у float
            e = float(e_str)
        except ValueError:  # якщо виникла помилка при перетворенні
            print("Помилка! Введіть число")  # виведення відповідного повідомлення
            continue  # починає наступну ітерацію циклу

        else:  # якщо е успішно перетворено з str у float
            if e <= 0 or e >= 1:  # перевіряємо значення точності
                print("Помилка: точність повинна бути в межах (0; 1)!")  # виведення відповідного повідомлення
            else:  # якщо введено вірно
                break  # зупиняємо цикл

    # введення початкового кроку
    print("\nВведіть початковий крок:")
    while True:  # цикл працює поки не виконається break
        step_str = input("Крок = ")  # вводимо початковий крок

        try:  # спробуємо перетворити step_str з str у float
            step = float(step_str)
        except ValueError:  # якщо виникла помилка при перетворенні
            print("Помилка при введенні початкового кроку! Спробуйте знову")  # виведення відповідного повідомлення
            continue # починає наступну ітерацію циклу

        break  # зупиняємо цикл

    # введення а, b, y (коефіцієнтів методу)
    while True:
        print("\nВведіть коефіцієнти (alpha, beta, gamma):")
        alpha_str = input("alpha (відбиття) = ") # введення а
        beta_str = input("beta (стиснення) = ") # введення b
        gamma_str = input("gamma (розтягнення) = ") # введення y

        try: # спробуємо перетворити з str у float
            alpha = float(alpha_str)
            beta = float(beta_str)
            gamma = float(gamma_str)

        except ValueError: # якщо виникла помилка при перетворенні
            print("\nПомилка при введенні змінних! Спробуйте ще раз") # виведення відповідного повідомлення
            continue # починає наступну ітерацію циклу

        else: # якщо успішно перетворено
            break # зупиняємо цикл

    # виведення введених даних
    print("\nВведені дані:")
    print("Функція:", f)
    print("Початкова точка: x =", x_val, ", y =", y_val)
    print("Точність:", e)
    print("Крок:", step)
    print(f"Параметри: alpha = {alpha}, beta = {beta}, gamma = {gamma}")

    # крок А (побудова початкового симплекса)
    n = 2                                                              # зберігаємо кількість змінних

    delta1 = (step / (n * math.sqrt(2))) * (math.sqrt(n + 1) + n - 1)  # розраховуємо дельта 1
    delta2 = (step / (n * math.sqrt(2))) * (math.sqrt(n + 1) - 1)      # розраховуємо дельта 2

    simplex = []                                                       # список для зберігання точок симплекса
    simplex.append([x_val, y_val])                                     # точка x0
    simplex.append([x_val + delta2, y_val + delta1])                   # точка x1
    simplex.append([x_val + delta1, y_val + delta2])                   # точка x2

    # виведення розрахунків
    print("\nПобудуємо початковий симплекс:")
    print(f"delta 1 = {delta1:.4f}\ndelta 2 = {delta2:.4f}")
    print(f"\nМаємо точки:\nx0 = ({simplex[0][0]:.4f}; {simplex[0][1]:.4f})")
    print(f"x1 = ({simplex[1][0]:.4f}; {simplex[1][1]:.4f})")
    print(f"x2 = ({simplex[2][0]:.4f}; {simplex[2][1]:.4f})\n")

    iteration = 0                                                      # ініціалізуємо лічильник ітерацій

    while True:  # основний цикл методу
        iteration += 1

        # крок Б (обчислення значень функції у вершинах)
        fun_xy = []                                                    # створюємо список який зберігатиме обчислене значення функції від x та y
        for i in range(n + 1):                                         # цикл для обчислення значення функції в точках
            val = fun(simplex[i][0], simplex[i][1])                    # обчислення f(x, y)
            fun_xy.append((val, i))                                    # додаємо до списку значення f(x, y) та індекс точки хi від якої обраховувалася функція

        fun_xy.sort(key=lambda pair: pair[0])                          # сортуємо за зростанням значення функції

        # зберігаємо індекси найкращої (l), наступної (g) та найгіршої (h) точок
        l_idx = fun_xy[0][1]                                           # індекс найменшого значення функції (l)
        g_idx = fun_xy[1][1]                                           # індекс середнього значення функції (g)
        h_idx = fun_xy[2][1]                                           # індекс найбільшого значення функції (h)

        # зберігаємо найменше, середнє та найбільше значення функції
        f_l = fun_xy[0][0]                                             # найменше значення функції
        f_g = fun_xy[1][0]                                             # середнє значення функції
        f_h = fun_xy[2][0]                                             # найбільше значення функції

        # зберігаємо точки в яких функція набуває найменшого, середнього та найбільшого значень
        x_l = simplex[l_idx]                                           # точка в якій значення функції найменше
        x_g = simplex[g_idx]                                           # точка в якій значення функції середнє
        x_h = simplex[h_idx]                                           # точка в якій значення функції найбільше

        # перевірка збіжності
        f_sigma  = sum(row[0] for row in fun_xy) / (n + 1)                # обчислюємо f для обрахування sigma
        sigma = math.sqrt(sum((row[0] - f_sigma ) ** 2 for row in fun_xy) / (n + 1)) # обрахування стандартного відхилення

        print(f"\n{iteration} ІТЕРАЦІЯ")
        print(f"    fl = {f_l:.4f} у т. ({x_l[0]:.4f}; {x_l[1]:.4f})")
        print(f"    fg = {f_g:.4f} у т. ({x_g[0]:.4f}; {x_g[1]:.4f})")
        print(f"    fh = {f_h:.4f} у т. ({x_h[0]:.4f}; {x_h[1]:.4f})")
        print(f"    Точність (sigma): {sigma:.4f}")

        if sigma < e:                                                     # якщо відхилення менше точності
            print("\nКритерій зупинки виконано (sigma < e)")              # виведення відповідного повідомлення
            break                                                         # зупиняємо цикл while

        # знаходження центру тяжіння х0
        x0 = [0.0, 0.0]                                                   # створюємо список, який зберігатиме точку центру тяжіння

        for i in range(n + 1):
            if i != h_idx:                                                # якщо не точка в якій значення функції найбільше
                x0[0] += simplex[i][0]                                    # обраховуємо суму перших координат точок
                x0[1] += simplex[i][1]                                    # обраховуємо суму других координат точок

        x0[0] /= n                                                        # обраховуємо першу координату точки центра тяжіння
        x0[1] /= n                                                        # обраховуємо другу координату точки центра тяжіння

        # проводимо відбиття
        xr = [(1 + alpha) * x0[0] - alpha * x_h[0], (1 + alpha) * x0[1] - alpha * x_h[1]] # обчислюємо координати точки xr після відбиття
        f_r = fun(xr[0], xr[1])                                                           # значення функції у відбитій точці

        # аналіз відбитої точки
        if f_r < f_l: # якщо значення функції у відбитій точці менше за найменше значення функції
            # проводимо розтягування
            xe = [gamma * xr[0] + (1 - gamma) * x0[0], gamma * xr[1] + (1 - gamma) * x0[1]] # обраховуємо координати точки після процесу розтягування
            f_e = fun(xe[0], xe[1])                                                         # обраховуємо значення функції в розтягненій точці

            if f_e < f_l: # якщо значення функції у розтягненій точці менше за найменше значення функції
                simplex[h_idx] = xe     # замінюємо xh на xe
            else: # якщо був зроблений занадто великий крок
                simplex[h_idx] = xr     # замінюємо xh на xr

        elif f_l < f_r <= f_g: # якщо значення функції у розтягненій точці менше за середнє значення функції
            simplex[h_idx] = xr         # замінюємо xh на xr

        elif f_r > f_g: # якщо значення функції у розтягненій точці, більше за середнє значення функції
            if f_r < f_h:               # порівняємо значення функцій fr і fh
                simplex[h_idx] = xr     # замінюємо xh на xr
                x_h = xr                # запам'ятовуємо значення xh
                f_h = f_r               # замінюємо fh на fr

            # проводимо стискання
            xc = [beta * x_h[0] + (1 - beta) * x0[0], beta * x_h[1] + (1 - beta) * x0[1]] # обраховуємо значення точки після стискання
            f_c = fun(xc[0], xc[1])                                                       # обраховуємо значення функції в точці xc

            # аналіз точки стиснення
            if f_c < f_h: # якщо значення функції в стиснутій точці менше за найбільше значення функції
                simplex[h_idx] = xc     # замінюємо xh на xc
            else: # якщо значення функції в стиснутій точці більше за найбільше значення функції
                for i in range(n + 1): # цикл для зменшення розмірності симплекса
                    simplex[i][0] = (simplex[i][0] + x_l[0]) / 2
                    simplex[i][1] = (simplex[i][1] + x_l[1]) / 2

    f_l = f_l * (-1) # домножуємо на -1, бо було змінено знаходження максимуму функції на знаходження мінімуму функції помноженням рівняння на -1

    # виведення результату
    print(f"\nОтже, максимум функції (з точністю до заданого значення e = {e:.4f})")
    print(f"знаходиться в точці ({x_l[0]:.4f}; {x_l[1]:.4f}) та становить {f_l:.4f}")

main()  # виклик головної функції програми