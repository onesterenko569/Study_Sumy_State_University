import math  # імпортуємо math, бо нам треба функція floor для дробної частини

EPS = 1e-9  # маленька похибка, щоб нормально порівнювати числа з плаваючою комою

# функція, яка повертає дробну частину числа
def frac(x: float) -> float:
    return x - math.floor(x + EPS) # віднімаємо цілу частину (через floor)

# функція перевірки чи число ціле
def is_int(x: float, tol=1e-7) -> bool:
    return abs(x - round(x)) <= tol  # якщо число близьке до цілого, то вважаємо цілим

# функція перетворення індексу змінної у назву (0 на x1)
def var_name(j: int) -> str:
    return f"x{j+1}" # повертаємо назву змінної

# функція друку симплекс-таблиці
def print_table(T, basis, title="Таблиця", prec=6, cell_w=10):
    m = len(T) - 1      # кількість рядків обмежень (останній рядок - це delta(F))
    rhs = len(T[0]) - 1 # індекс стовпця b (вільні члени рівнянь)
    n = rhs             # кількість змінних у таблиці (без b)

    # формуємо заголовок таблиці
    headers = ["Базис", "Вільні члени рівнянь"] + [var_name(j) for j in range(n)]

    widths = []                                      # список ширин колонок
    widths.append(max(len(headers[0]), cell_w))      # ширина для колонки "Базис"
    widths.append(max(len(headers[1]), cell_w + 10)) # ширина для колонки "Вільні члени рівнянь"

    for _ in range(n):                               # для всіх x1..xn
        widths.append(cell_w)                        # ставимо однакову ширину

    # внутрішня функція, яка збирає рядок з символом "|"
    def join_row(cells):
        return "| " + " | ".join(cells) + " |"

    # внутрішня функція форматування числа
    def num_cell(x: float, w: int) -> str:
        if abs(x) < 5e-13:      # якщо число дуже маленьке
            x = 0.0             # вважаємо що це 0

        s = f"{x:.{prec}f}"     # формуємо число з prec знаками після коми
        if s.startswith("-0."): # якщо вийшло -0.000000
            s = s[1:]           # прибираємо мінус

        return s.rjust(w)       # вирівнюємо вправо по ширині w

    print("\n" + title)         # друкуємо назву таблиці

    header_row = join_row(headers[i].center(widths[i]) for i in range(len(headers))) # друкуємо заголовок
    print(header_row)                                                                # вивід заголовка
    print("-" * len(header_row))                                                     # лінія з - як розділювач

    # друк рядків обмежень
    for i in range(m): # цикл по рядках обмежень
        row = []       # список значень рядка таблиці

        row.append(var_name(basis[i]).center(widths[0]))  # додаємо базисну змінну (наприклад x3)
        row.append(num_cell(T[i][rhs], widths[1]))        # додаємо вільний член (b)

        for j in range(n):                                # цикл по змінних x1..xn
            row.append(num_cell(T[i][j], widths[2 + j]))  # додаємо коефіцієнт при xj

        print(join_row(row)) # друкуємо сформований рядок

    # друк рядка delta
    row = []  # список значень для останнього рядка
    row.append("delta".center(widths[0]))                # замість базису пишемо delta
    row.append(num_cell(T[-1][rhs], widths[1]))          # у цій колонці друкуємо значення delta
    for j in range(n):                                   # цикл по коефіцієнтах delta
        row.append(num_cell(T[-1][j], widths[2 + j]))    # друкуємо оцінки по змінних

    print("-" * len(header_row))  # розділювач перед рядком delta
    print(join_row(row))          # друкуємо останній рядок

# функція реалізує перетворення симплекс-таблиці, яке відповідає переходу від одного базисного плану до іншого
def simplex_table_transformation(T, basis, r, c):
    m = len(T) - 1            # кількість рядків обмежень
    rhs = len(T[0]) - 1       # індекс стовпця b
    n = rhs                   # кількість змінних

    p = T[r][c]  # опорний елемент таблиці
    if abs(p) < EPS:  # якщо опорний елемент таблиці майже дорівнює нулю
        raise ZeroDivisionError("Опорний елемент дорівнює нулю") # ділення неможливе

    for j in range(n + 1):  # нормалізуємо опорний рядок (включно з b)
        T[r][j] /= p        # ділимо рядок на опорний елемент

    for i in range(m + 1):      # цикл по всіх рядках (включно з delta(F))
        if i == r:              # якщо опорний рядок
            continue            # пропускаємо

        k = T[i][c]             # множник для занулення
        if abs(k) < EPS:        # якщо і так майже 0
            continue            # пропускаємо

        for j in range(n + 1):     # цикл по всіх стовпцях таблиці, включно з колонкою вільних членів b
            T[i][j] -= k * T[r][j] # віднімаємо k * pivot_row, щоб зробити 0 у колонці c

    basis[r] = c  # оновлюємо базис (у рядку r тепер стоїть змінна c)

# функція реалізації прямого симплекс-методу для задачі лінійного програмування на максимум
def direct_simplex(T, basis, show=False, label="ЛП-релаксація", prec=6, cell_w=10):
    m = len(T) - 1       # кількість рядків обмежень
    rhs = len(T[0]) - 1  # індекс b
    n = rhs              # кількість змінних
    it = 0               # лічильник ітерацій

    if show: # якщо потрібно виводити таблиці
        print_table(T, basis, "Початкова симплекс-таблиця", prec=prec, cell_w=cell_w) # друкуємо таблицю

    while True:  # головний цикл симплекса
        it += 1  # збільшуємо номер ітерації
        last = T[-1] # беремо останній рядок delta(F)

        entering = None  # змінна яка входить в базис
        min_val = -EPS   # шукаємо найменший від’ємний коефіцієнт

        for j in range(n):           # цикл по всіх змінних
            if last[j] < min_val:    # якщо коефіцієнт більш від’ємний
                min_val = last[j]    # оновлюємо мінімум
                entering = j         # запам’ятовуємо стовпець

        if entering is None:  # якщо від’ємних нема
            if show: # якщо потрібно виводити таблиці
                print_table(T, basis, f"Оптимальна симплекс-таблиця (ітерацій {it-1})", prec=prec, cell_w=cell_w) # друкуємо таблицю

            return  # виходимо, бо оптимум знайдено

        leaving = None             # рядок, який виходить з базису
        best_ratio = float("inf")  # найкраще відношення b/a

        for i in range(m):              # цикл по рядках обмежень
            a = T[i][entering]          # коефіцієнт у entering-колонці
            if a > EPS:                 # беремо тільки додатні a
                ratio = T[i][rhs] / a   # рахуємо b/a
                if ratio < best_ratio - EPS: # мінімізуємо b/a
                    best_ratio = ratio # запам’ятовуємо найменше знайдене відношення b/a
                    leaving = i        # запам’ятовуємо номер рядка (базисної змінної), яка виходить з базису

        if leaving is None:  # якщо нема додатніх a то задача необмежена
            raise RuntimeError("ЛП-релаксація необмежена")

        simplex_table_transformation(T, basis, leaving, entering)  # робимо pivot

        if show:  # якщо треба виводити таблицю
            print_table(T, basis, f"Симплекс-таблиця після ітерації {it}", prec=prec, cell_w=cell_w) # друк таблиці

# функція реалізації двійкового симплекс-методу
def dual_simplex(T, basis, show=False, label="Двійковий симплекс", prec=6, cell_w=10):
    m = len(T) - 1      # кількість рядків обмежень
    rhs = len(T[0]) - 1 # індекс стовпця вільних членів рівнянь b
    n = rhs             # кількість змінних у задачі

    it = 0              # лічильник ітерацій

    if show: # якщо потрібно виводити таблицю
        print_table(T, basis, f"{label}", prec=prec, cell_w=cell_w) # друк таблиці

    while True: # головний цикл двійкового симплекса, який повторюється, доки в таблиці є від’ємні вільні члени b
        it += 1 # збільшуємо кількість ітерацій

        leaving = None   # рядок з поганим b (b < 0)
        most_neg = -EPS  # шукаємо найбільш від’ємне b

        for i in range(m):           # цикл по рядках
            if T[i][rhs] < most_neg: # якщо b ще більш від’ємне
                most_neg = T[i][rhs] # оновлюємо найбільш від’ємне значення вільного члена b
                leaving = i          # запам’ятовуємо номер рядка, який має найбільш від’ємне b і буде виправлятися

        if leaving is None:  # якщо всі b >= 0
            if show:         # якщо потрібно виводити таблицю
                # друк таблиці
                print_table(T, basis, f"{label}: допустимість відновлено (ітерацій {it-1})", prec=prec, cell_w=cell_w)
            return # виходимо

        entering = None             # стовпець, який входить у базис
        best_ratio = float("inf")   # мінімізуємо відношення delta / (-a)

        for j in range(n):                   # цикл по змінних
            a = T[leaving][j]                # коефіцієнт у проблемному рядку
            if a < -EPS:                     # беремо тільки від’ємні
                ratio = T[-1][j] / (-a)      # рахуємо delta / (-a)
                if ratio < best_ratio - EPS: # якщо знайдене відношення delta / (-a) менше за поточне найкраще
                    best_ratio = ratio       # оновлюємо мінімальне значення цього відношення
                    entering = j             # запам’ятовуємо номер стовпця змінної, яка увійде в базис

        if entering is None:  # якщо немає від’ємних коефіцієнтів, то неможливо виконати перетворення таблиці
            # виведення відповідного повідомлення
            raise RuntimeError("Двійковий симплекс: неможливо відновити допустимість (нема a < 0)")

        # виконуємо перетворення симплекс-таблиці та змінюємо базис
        simplex_table_transformation(T, basis, leaving, entering)

        if show: # якщо потрібно виводити таблицю
            # друк таблиці
            print_table(T, basis, f"Відновлення допустимості: ітерація {it}", prec=prec, cell_w=cell_w)

# функція відновлення вектора розв’язку x з симплекс-таблиці
def recovery_solution_vector_x(T, basis, var_count):
    m = len(T) - 1            # кількість рядків обмежень
    rhs = len(T[0]) - 1       # індекс b
    x = [0.0] * var_count     # створюємо список для всіх змінних і заповнюємо нулями

    for i in range(m):        # цикл по базисних рядках
        bi = basis[i]         # яка змінна стоїть в базисі
        if bi < var_count:    # якщо це одна з потрібних змінних
            x[bi] = T[i][rhs] # записуємо її значення з b

    return x  # повертаємо вектор x

# головна функція реалізації методу Гоморі
def gomori_method(A, b, c, integer_vars, max_cuts=30, show_tables=True, prec=3, cell_w=7):
    m = len(A)        # зберігаємо кількість обмежень
    n = len(A[0])     # зберігаємо кількість змінних у початковій таблиці

    # формуємо таблицю: до кожного рядка A додаємо справа b
    T = [row[:] + [bi] for row, bi in zip(A, b)]

    # додаємо останній рядок delta j
    T.append([-ci for ci in c] + [0.0])

    basis = []  # список базисних змінних

    # шукаємо одиничні стовпці щоб визначити стартовий базис
    for i in range(m):     # цикл по рядках обмежень
        col = None         # змінна, куди запишемо номер стовпця, який підходить як базисний

        for j in range(n): # цикл по всіх стовпцях змінних

            # перевірка: тут має бути 1, а в інших рядках цього стовпця мають бути 0
            if abs(T[i][j] - 1.0) < EPS and all(abs(T[k][j]) < EPS for k in range(m) if k != i):
                col = j # якщо умова виконалась, то значить що стовпець j є одиничним для рядка i
                break   # виходимо з циклу по j, бо базис для цього рядка вже знайдено

        if col is None: # якщо після проходу всіх стовпців ми так і не знайшли одиничний стовпець
            raise RuntimeError("Помилка! Не знайдено початкового одиничного базису") # друкуємо помилку

        basis.append(col) # додаємо знайдений номер стовпця в список basis

    # вирішуємо задачу як задачу лінійного програмування
    direct_simplex(T, basis, show=show_tables, label="ЛП-релаксація", prec=prec, cell_w=cell_w)

    cuts = 0  # лічильник відсікань

    while cuts < max_cuts:       # обмежуємо кількість відсікань, щоб не зациклитися
        rhs_col = len(T[0]) - 1  # індекс колонки b

        row_choice = None  # який рядок виберемо для відсікання
        best_f = 0.0       # найбільша дробна частина серед нецілих

        for i in range(len(T) - 1):   # цикл по рядках обмежень (без delta(F))
            bi = basis[i]             # яка змінна в базисі
            if bi in integer_vars and not is_int(T[i][rhs_col]):  # якщо вона має бути цілою, але не ціла
                f = frac(T[i][rhs_col])  # беремо дробну частину
                if f > best_f + 1e-12:   # обираємо найбільшу дробну частину
                    best_f = f     # запам’ятовуємо найбільшу дробну частину серед нецілих значень базисних змінних
                    row_choice = i # запам’ятовуємо номер рядка, для якого буде будуватися відсікання Гоморі

        if row_choice is None: # якщо не знайдено жодного рядка з нецілим значенням базисної змінної
            break              # якщо нецілих вже нема то завершуємо цикл

        r = row_choice                  # рядок, по якому будуємо відсікання
        fb = frac(T[r][rhs_col])        # дробна частина вільного члена

        for i in range(len(T)):         # додаємо нову колонку під нову змінну
            T[i].insert(rhs_col, 0.0)   # вставляємо нулі перед b

        new_var_index = n  # індекс нової змінної
        n += 1             # збільшуємо кількість змінних у таблиці
        rhs_col += 1       # тепер b зсунувся на 1 вправо

        new_row = [0.0] * (n + 1)  # створюємо новий рядок (нове обмеження)

        for j in range(n - 1):             # коефіцієнти для x1..x(n-1)
            new_row[j] = -frac(T[r][j])    # беремо дробні частини і ставимо зі знаком -

        new_row[new_var_index] = 1.0       # коефіцієнт при новій змінній (як додаткова змінна)
        new_row[rhs_col] = -fb             # справа буде -{b}, тому часто b стає від’ємним

        T.insert(len(T) - 1, new_row)      # вставляємо рядок перед delta(F)
        basis.append(new_var_index)        # нова змінна стає базисною в новому рядку

        cuts += 1  # збільшуємо лічильник відсікань

        if show_tables: # якщо show_tables = True
            # друкуємо таблицю
            print_table(T, basis, f"Симплекс-таблиця після відсікання {cuts}", prec=prec, cell_w=cell_w)

        # після відсікання часто b < 0, тому використовуємо двійковий симплекс
        dual_simplex(T, basis, show=show_tables, label=f"Двійковий симплекс після відсікання {cuts}", prec=prec, cell_w=cell_w)

    sol = recovery_solution_vector_x(T, basis, n)  # витягуємо рішення з таблиці
    F = T[-1][-1]                        # значення цільової функції (у нашій таблиці воно тут)

    return sol, F, cuts                  # повертаємо рішення, F і кількість відсікань

# головна функція програми
def main():
    # матриця обмежень
    A = \
    [
        [6,  4, 1, 0, 0],   # перше обмеження: 6x1 + 4x2 + x3 = 24
        [3, -3, 0, 1, 0],   # друге обмеження: 3x1 - 3x2 + x4 = 9
        [-1, 3, 0, 0, 1]    # третє обмеження: -x1 + 3x2 + x5 = 3
    ]

    b = [24, 9, 3]          # праві частини рівнянь обмежень (вільні члени)

    c = [2, 1, 0, 0, 0]     # цільова функція: F = 2x1 + x2 (інші з нульовим коефіцієнтом)

    integer_vars = {0, 1, 2, 3, 4}  # змінні x1..x5 повинні бути цілими

    # розв'язуємо задачу методом Гоморі
    sol, F, cuts = (gomori_method
    (
        A, b, c,
        integer_vars=integer_vars,
        max_cuts=30,        # максимум 30 відсікань, щоб програма не зациклилась
        show_tables=True,   # True = друкуємо всі таблиці, False = не друкуємо
        prec=3,             # 6 знаків після коми для таблиць
        cell_w=7           # ширина клітинок у таблиці
    ))

    # виведення результатів обчислень
    print("\nРезультат проведених обчислень:")
    for i in range(5):  # цикл по x1..x5
        v = sol[i]      # значення змінної
        print(f"x{i+1} = {int(round(v)) if is_int(v) else v}") # якщо число ціле, то виводимо як int

    print(f"F_max = {int(round(F)) if is_int(F) else F}") # друкуємо максимальне значення F
    print(f"Скільки разів додавали обмеження Гоморі: {cuts}")                 # друкуємо скільки разів додавали обмеження Гоморі

main() # виклик головної функції програми