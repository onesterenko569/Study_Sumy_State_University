import sympy as sp # підключаємо модуль для введення функції користувачем

# функція для обчислення точки максимуму методом Хука-Дживса
def hooke_jeeves_max(f, x0, y0, step, epsilon):
    x, y = sp.symbols('x y')                                                       # створюємо символічні змінні x та y
    f_num = sp.lambdify((x, y), f, "math")                            # створюємо числову функцію f_num(x, y)

    xb, yb = x0, y0                                                                # запам'ятовуємо поточну точку
    iteration = 1                                                                  # оголошуємо лічильник ітерацій

    while step > epsilon:                                                          # цикл виконуватиметься, доки не буде досягнуто необхідної точності
        print(f"\nІтерація {iteration}")
        print(f"Точка B = ({xb:.2f}, {yb:.2f}), f = {f_num(xb, yb):.2f}")          # виведення координат точок та значення функції в цій точці
        iteration += 1                                                             # збільшуємо лічильник ітерацій

        xn, yn = xb, yb                                                            # тимчасові змінні які набувають значення поточної точки

        # рух по х
        f_center = f_num(xn, yn)                                                   # запам'ятовуємо значення функції в заданій точці
        f_right = f_num(xn + step, yn)                                             # рух вправо по х
        f_left  = f_num(xn - step, yn)                                             # рух вліво по х

        # виводимо значення функції в точках з зміненим значенням х
        print(f"Перевірка по X:")
        print(f"  f({xn+step:.2f}, {yn:.2f}) = {f_right:.2f}")
        print(f"  f({xn-step:.2f}, {yn:.2f}) = {f_left:.2f}")

        if f_right > f_center:                                                     # якщо відбулось збільшення функції при збільшенні х на крок
            xn += step                                                             # збільшуємо х на крок
            print("  рух вправо ( +step )")                                        # виведення відповідного повідомлення
        elif f_left > f_center:                                                    # якщо відбулось збільшення функції при зменшенні х на крок
            xn -= step                                                             # зменшуємо х на крок
            print("  рух вліво ( -step )")                                         # виведення відповідного повідомлення
        else:                                                                      # якщо змінюючи х покращень немає
            print("  покращення по X немає")

        # рух по у
        f_center = f_num(xn, yn)                                                   # оновлюємо значення функції
        f_up = f_num(xn, yn + step)                                                # рух вгору по у
        f_down = f_num(xn, yn - step)                                              # рух вниз по у

        # виводимо значення функції в точках з зміненим значенням y
        print(f"Перевірка по Y:")
        print(f"  f({xn:.2f}, {yn+step:.2f}) = {f_up:.2f}")
        print(f"  f({xn:.2f}, {yn-step:.2f}) = {f_down:.2f}")

        if f_up > f_center:                                                        # якщо відбулось збільшення функції при збільшенні у на крок
            yn += step                                                             # збільшуємо у на крок
            print("  рух вгору ( +step )")                                         # виведення відповідного повідомлення
        elif f_down > f_center:                                                    # якщо відбулось збільшення функції при зменшенні у на крок
            yn -= step                                                             # зменшуємо у на крок
            print("  рух вниз ( -step )")                                          # виведення відповідного повідомлення
        else:                                                                      # якщо змінюючи у покращень немає
            print("  покращення по Y немає")

        # виконаємо пошук за зразком
        if f_num(xn, yn) > f_num(xb, yb):                                          # якщо досліджувальний пошук покращив значення функції
            print(f"Покращення знайдено: f_new = {f_num(xn, yn):.2f} > f_old = {f_num(xb, yb):.2f}")
            print("Виконаємо пошук за зразком")

            old_xb, old_yb = xb, yb                                                # запам'ятовуємо минулі координати
            xb, yb = xn, yn                                                        # оновлюємо поточні координати

            xp = old_xb + 2 * (xb - old_xb)                                        # обраховуємо х за зразком
            yp = old_yb + 2 * (yb - old_yb)                                        # обраховуємо у за зразком

            print(f"  P = ({xp:.2f}, {yp:.2f}), f = {f_num(xp, yp):.2f}")          # виведення обрахованої точки та значення функції в цій точці

            if f_num(xp, yp) > f_num(xb, yb):                                      # якщо відбулося покращення функції
                xb, yb = xp, yp                                                    # оновлюємо значення поточних точок
                print("  пошук за зразком покращує, приймаємо нову точку B")
            else:                                                                  # якщо покращення не відбулося
                print("  пошук за зразком не покращує, лишаємо B")
        else:                                                                      # якщо досліджувальний пошук не покращив значення функції
            print("Покращення не знайдено, зменшуємо крок")
            step /= 2                                                              # зменшуємо крок вдвічі
            print(f"Новий крок: {step}")

    return xb, yb, f_num(xb, yb), step                                             # повертаємо покращені координати та значення функції в цій точці

def main():                                                                  # головна функція програми
    print("\n____ЗНАХОДЖЕННЯ ТОЧКИ МАКСИМУМУ ФУНКЦІЇ ЗА МЕТОДОМ ХУКА – ДЖИВСА____\n")

    # введення функції користувачем
    x, y = sp.symbols('x y')                                                 # створюємо символічні змінні x та y
    while True:                                                              # цикл працює поки не виконається break
        user_function = input("Введіть функцію f(x, y): ")                   # користувач вводить функцію

        try:                                                                 # спробуємо виконати наступний блок коду
            f = sp.sympify(user_function)                                    # перетворюємо текст у математичний вираз
        except (sp.SympifyError, SyntaxError):                               # якщо виникла помилка при перетворенні тексту в мат. вираз
            print("Помилка! Введено некоректну функцію. Спробуйте ще раз.")  # виведення відповідного повідомлення
            continue                                                         # переходимо до наступної ітерації циклу

        if not f.has(x) and not f.has(y):                                    # якщо у введеній функції немає x або y
            print("Функція повинна містити x або y!")                        # виведення відповідного повідомлення
            continue                                                         # переходимо до наступної ітерації циклу

        break                                                                # зупиняємо цикл, якщо функцію було вірно введено

    print("Функція успішно введена!")                                        # виведення повідомлення про успіх

    # введення початкової точки
    print("\nВведіть координати початкової точки:")
    while True:                                                              # цикл працює поки не виконається break
        x_str = input("x = ")                                                # вводимо х
        y_str = input("y = ")                                                # вводимо у

        try:                                                                 # спробуємо перетворити х та у з str у float
            x_val = float(x_str)
            y_val = float(y_str)
        except ValueError:                                                   # якщо виникла помилка при перетворенні
            print("Помилка при введенні координат! Спробуйте знову")         # виведення відповідного повідомлення
            continue                                                         # починає наступну ітерацію циклу

        break                                                                # зупиняє цикл, якщо координати точки було введено правильно

    # введення точності
    while True:                                                              # цикл працює поки не виконається break
        e_str = input("\nВведіть точність обчислень: ")                      # вводимо точність обчислень

        try:                                                                 # спробуємо перетворити е з str у float
            e = float(e_str)
        except ValueError:                                                   # якщо виникла помилка при перетворенні
            print("Помилка! Введіть число")                                  # виведення відповідного повідомлення
            continue                                                         # починає наступну ітерацію циклу

        else:                                                                # якщо е успішно перетворено з str у float
            if e <= 0 or e >= 1:                                             # перевіряємо значення точності
                print("Помилка: точність повинна бути в межах (0; 1)!")      # виведення відповідного повідомлення
            else:                                                            # якщо введено вірно
                break                                                        # зупиняємо цикл

    # введення початкового кроку
    print("\nВведіть початковий крок:")
    while True:                                                              # цикл працює поки не виконається break
        step_str = input("Крок = ")                                          # вводимо початковий крок

        try:                                                                 # спробуємо перетворити step_str з str у float
            step = float(step_str)
        except ValueError:                                                   # якщо виникла помилка при перетворенні
            print("Помилка при введенні початкового кроку! Спробуйте знову") # виведення відповідного повідомлення
            continue                                                         # починає наступну ітерацію циклу

        break                                                                # зупиняємо цикл

    # виведення введених даних
    print("\nВведені дані:")
    print("Функція:", f)
    print("Початкова точка: x =", x_val, ", y =", y_val)
    print("Точність:", e)
    print("Крок:", step)

    xmax, ymax, fmax, stepmax = hooke_jeeves_max(f, x_val, y_val, step, e)            # викликаємо функцію та отримуємо остаточні результати

    print(f"\nОскільки довжина кроку h = {stepmax:.2f} і < за e (точність обчислень), закінчуємо розрахунок")
    print("Отже, максимум функції (з точністю до заданого значення e = ", e, ")")
    print("знаходиться в точці (", xmax, ",", ymax, ") та становить ", fmax)          # виведення результатів

main()                                                                       # виклик головної функції програми
