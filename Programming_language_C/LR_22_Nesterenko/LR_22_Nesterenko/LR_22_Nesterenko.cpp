#include<stdio.h> // підключення бібліотеки
#include<stdlib.h> // підключення бібліотеки

struct node // головна структура (прототип)
{
	int data; // оголошення змінної типу int
	struct node* next; // для наступної структури
};
typedef struct node STACK; // переіменовуємо struct node для зручності

STACK* push(STACK* TOP, int value) // функція для додавання елементів у стек
{
	STACK* p; // оголошення стеку 
	p = (STACK*)malloc(sizeof(STACK)); // виділення пам'яті під оголошений стек
	if (p == NULL) // перевірка чи пам'ять виділена
	{
		printf("Problema pry vydilenni pamyati\n"); // виведення відповідного повідомлення
		exit(0); // завершення програми з помилкою
	}
	p->data = value; // у стек p передаємо значення яке треба додати
	p->next = TOP; // робимо стек p вершиною
	TOP = p; // робимо стек TOP вершиною
	return(TOP); // повертаємо TOP (нова, додана вершина)
}

STACK* pop(STACK* TOP, int *value) // функція для витягування даних зі стеку
{
	STACK* p; // оголошення стеку
	if (TOP == NULL) // перевірка чи стек щось містить
	{
        printf("Stek pustyy\n"); // виведення відповідного повідомлення
		exit(0); // завершення програми з помилкою
	}
	*value = TOP->data; // забираємо значення з вершини стеку
	p = TOP; // тепер вершина це не тільки стек TOP а й p
	TOP = TOP->next; // переходимо до наступного стеку (переносимо вершину)
	free(p); // видаляємо попередній стек, так як потрібну інформацію отримали
	return(TOP); // повертаємо TOP
}

STACK* add(STACK* S1, STACK* S2) // функція для додавання стеку S2 до S1
{
    STACK* p = NULL; // оголошення стеку
    int value; // оголошення змінної типу int

    while (S2 != NULL) // отримуємо значення зі стеку S2 та переносимо їх до стеку p
    {
        S2 = pop(S2, &value); // розгортаємо стек S2
        p = push(p, value); // заповнюємо стек p
    }

    while (p != NULL) // отримуємо значення зі стеку p та переносимо їх до стеку S1
    {
        p = pop(p, &value); // розгортаємо стек p
        S1 = push(S1, value); // заповнюємо стек S1
    }
    return S1; // поветаємо стек S1
}

void output(STACK* TOP) // функція для виведення стеку
{
    while (TOP != NULL) // цикл до поки стек не закінчиться
    {
        printf("%d ", TOP->data); // виводимо дані з вершини стеку
        TOP = TOP->next; // переходимо до наступного елементу стеку
    }
    printf("\n"); // для початку з нового рядка
}

int main() // головна функція програми
{
    STACK* S1 = NULL; // оголошення стеку
    STACK* S2 = NULL; // оголошення стеку
    int n_1, n_2, value; // оголошення змінних типу int

    printf("Vvedit kilkist elementiv dlya steky S1: "); // виведення тексту
    scanf_s("%d", &n_1); // введення кількості елементів для стеку S1
    printf("Vvedit kilkist elementiv dlya steky S2: "); // виведення тексту
    scanf_s("%d", &n_2); // введення кількості елементів для стеку S1
    printf("\n");

    for (int i = 0; i < n_1; i++) // цикл для введення стеку S1
    {
        printf("Vvedit element %d dlya S1: ", i + 1); // виведення тексту
        scanf_s("%d", &value); // введення елементу стеку
        S1 = push(S1, value); // додавання введеного елемента до стеку S1
    }
    printf("\n");

    for (int i = 0; i < n_2; i++) //  цикл для введення стеку S2
    {
        printf("Vvedit element %d dlya S2: ", i + 1); // виведення тексту
        scanf_s("%d", &value); // введення елементу стеку
        S2 = push(S2, value); // додавання введеного елемента до стеку S2
    } 
    
    printf("\nS1:\n"); // виведення тексту
    output(S1); // виведення початкового стеку S1
    
    printf("\nS2:\n"); // виведення тексту
    output(S2); // виведення початкового стеку S2

    S1 = add(S1, S2); // додавання стеку S2 до S1

    printf("\nPislya pryyednannya S2 do S1:\n"); // виведення тексту
    output(S1); // виведення оновленого стеку S1
     
    while (S1 != NULL) // цикл для звільнення пам'яті
    {
        S1 = pop(S1, &value); // звільнення пам'яті
    }

    return 0; // завершення програми
}
