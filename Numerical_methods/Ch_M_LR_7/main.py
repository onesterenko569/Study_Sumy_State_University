import sympy as sp
import numpy as np

# функція обрахунку наступного y для x + h
def y_next_with_step_h(f, x, y, h):
    k1 = h * f(x, y)                         # обраховуємо k1
    k2 = h * f(x + h / 2, y + k1 / 2)        # обраховуємо k2
    k3 = h * f(x + h / 2, y + k2 / 2)        # обраховуємо k3
    k4 = h * f(x + h, y + k3)                # обраховуємо k4
    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6 # повертаємо обрахований y для x + h

# функція реалізації методу Рунге-Кутти 4 порядку
def Runge_Kutta_4_method(f, a, b, y0, h):
    x = a   # змінна для значення х
    y = y0  # змінна для значення у

    x_val = [x] # масив для збереження х від a до b з кроком h
    y_val = [y] # масив для збереження значень у для відповідного х

    while x + h <= b: # цикл триває, поки не дійдемо до правої межі відрізку b
        y = y_next_with_step_h(f, x, y, h) # обраховуємо наступний у для х + h
        x += h                             # збільшуємо х на крок
        x_val.append(x)                    # додаємо обрахований х до масиву
        y_val.append(y)                    # додаємо обрахований у до масиву

    return np.array(x_val), np.array(y_val) # повертаємо обраховані масиви

def main(): # головна функція програми
    # створюємо математичні змінні для x та y
    x_symbol, y_symbol = sp.symbols('x y')
    allowed_symbols = {x_symbol, y_symbol}

    while True: # введення правої частини диференціального рівняння користувачем
        try:
            function_str = input("Введіть диференціальне рівняння вигляду y' = f(x, y):\ny' = ") # вводимо праву частину диф. рівняння

            if not function_str.strip(): # перевірка на порожній рядок
                print("Помилка! Введено пустий рядок")
                continue # розпочинаємо цикл спочатку

            function = sp.sympify(function_str, locals={'e': sp.exp(1)}) # створюємо функцію щоб програма знала число e (експоненту)

            if not function.free_symbols: # перевірка на наявність хоча б однієї змінної
                print("Помилка! Ви ввели константу, а не функцію (відсутні змінні x або y)")
                continue # розпочинаємо цикл спочатку

            # перевірка чи є зайві змінні
            error_vars = function.free_symbols - allowed_symbols # з введених змінних прибираємо х та y
            if error_vars: # якщо ще є символьні змінні окрім х
                print(f"Помилка! Знайдено невідомі змінні: {error_vars}")
                print("Дозволено використовувати лише 'x' та 'y'")
                continue

            f = sp.lambdify((x_symbol, y_symbol), function, 'numpy') # створюємо функцію для обчислень

            print("Функцію успішно прийнято!")
            break

        except Exception as e: # якщо виникла помилка
            print(f"Помилка при введенні функції: {e}")

    while True: # введення початкового значення відрізка [a, b]
        try: # спробуємо виконати наступний блок коду
            a = float(input("\nВведіть початкове значення відрізка [a, b]:\na = "))
            break
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    while True: # введення кінцевого значення відрізка [a, b]
        try: # спробуємо виконати наступний блок коду
            b = float(input("\nВведіть кінцеве значення відрізка [a, b]:\nb = "))

            if a >= b:
                print("Помилка! b повинно бути більше за a")
            else:
                break
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    while True: # введення y0
        try: # спробуємо виконати наступний блок коду
            y0 = float(input(f"\nВведіть значення y при x = {a}:\ny = ")) # вводимо y0
            break # якщо введено правильно, зупиняємо цикл
        except ValueError: # якщо виникла помилка
                print("Помилка! Введіть число")

    while True: # введення кроку h
        try: # спробуємо виконати наступний блок коду
            h = float(input(f"\nВведіть крок:\nh = ")) # вводимо h
            if (b - a) < h: # якщо крок введено не правильно
                print("Крок введено не правильно, спробуйте ще раз")
                continue
            else: # якщо введено правильно
                break # зупиняємо цикл
        except ValueError: # якщо виникла помилка
                print("Помилка! Введіть число")

    while True: # введення точності обчислень е
        try: # спробуємо виконати наступний блок коду
            epsilon = float(input("\nВведіть точність обчислень:\ne = "))

            if epsilon <= 0 or epsilon >= 1: # якщо введено не правильно
                print("Помилка! Значення e введено не правильно")
            else: # якщо введено правильно
                break # зупиняємо цикл
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    h0 = h # зберігаємо початковий крок для кінцевого виведення результатів
    x_t = np.arange(a, b + h0 / 2, h0)  # створюємо масив від a до b включно з кроком h0 (введений користувачем)

    while True: # цикл працюватиме поки не спрацює break

        x_h, y_h = Runge_Kutta_4_method(f, a, b, y0, h)       # обраховуємо набір точок з кроком h
        x_h2, y_h2 = Runge_Kutta_4_method(f, a, b, y0, h / 2) # обраховуємо набір точок з поділеним навпіл кроком (h / 2)

        y_cur = []    # масив для витягнутих у з масиву y_h із початковим кроком h0
        y_n = []      # масив для витягнутих у з масиву y_h2 із початковим кроком h0
        mistakes = [] # масив для збереження значень похибок

        k = int(round(h0 / h)) # обраховуємо через скільки дрібних кроків h ми потрапимо в точку h0 (скільки h в h0)

        for i, x_val in enumerate(x_t): # цикл для витягування значень у для відповідного х з початковим кроком h0
            idx1 = min(i * k, len(y_h) - 1) # беремо індекс елементу у масиві y_h з захистом від виходу за межі масиву
            idx2 = min(i * 2 * k, len(y_h2) - 1) # беремо індекс елементу у масиві y_h2 з захистом від виходу за межі масиву

            y_current = y_h[idx1] # витягуємо у з початковим кроком h0 із масиву y_h
            y_next = y_h2[idx2]   # витягуємо у з початковим кроком h0 із масиву y_h2

            mistake = abs(y_current - y_next) / (15) # обраховуємо похибку
            mistakes.append(mistake) # додаємо обраховану похибку до масиву похибок

            y_cur.append(y_current)  # додаємо значення y_current в масив y_cur
            y_n.append(y_next)       # додаємо значення y_next в масив y_n

        max_mistake = max(mistakes)  # знаходимо максимально похибку

        if max_mistake <= epsilon: # якщо максимальна похибка менша або дорівнює заданій точності

            print(f"\nРозв'язок успішно знайдено з заданою точністю e = {epsilon} та кроком розбиття {h}")

            # виведення заголовку таблиці
            print("\n    x    |      y      |   Похибка")
            print("--------------------------------------")

            for i, x_val in enumerate(x_t): # цикл для витягування значень у для відповідного х з початковим кором
                print(f"   {x_val:.1f}   |   {y_cur[i]:.5f}   |   {mistakes[i]:.2e}") # виведення рядків таблиці
            break # завершуємо цикл

        else: # якщо похибка більша за задану точність
            h /= 2 # зменшуємо крок удвічі

main() # виклик головної функції програми
