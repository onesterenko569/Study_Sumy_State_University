import sympy as sp

# обчислює суму парних та непарних значень функції (по їх індексах)
def sum_even_and_not_even(y_arr):
    sum_even = 0 # зберігатиме суму парних значень функції
    sum_not_even = 0 # зберігатиме суму непарних значень функції

    for i in range(1, len(y_arr) - 1): # цикл без значень функцій у крайніх точках
        if i % 2 == 0: # якщо індекс парний
            sum_even += y_arr[i] # сумуємо
        else: # якщо індекс непарний
            sum_not_even += y_arr[i] # сумуємо

    return sum_even, sum_not_even # повертаємо обчислені значення

# обчислює значення функції за формулою Сімпсона
def simpson(h, y_arr):
    sum_even, sum_not_even = sum_even_and_not_even(y_arr) # обчислюємо суму парних та непарних значень функції
    s = h/3 * (y_arr[0] + y_arr[-1] + 2 * sum_even + 4 * sum_not_even) # обчислюємо за формулою Сімпсона
    return s  # повертаємо обчислене значення


def main(): # головна функція програми
    x_symbol = sp.symbols('x') # створюємо математичну змінну

    while True: # введення підінтегральної функції користувачем
        try:
            function_str = input("Введіть підінтегральну функцію f(x): ") # вводимо функцію (рядок)

            if not function_str.strip(): # перевірка на порожній рядок
                print("Помилка! Введено пустий рядок")
                continue

            function = sp.sympify(function_str, locals={'e': sp.exp(1)}) # створюємо функцію щоб програма знала число e

            if x_symbol not in function.free_symbols: # якщо користувач не ввів х
                print("Помилка! Ви ввели не функцію (відсутня змінна x)")
                continue

            # перевірка чи є зайві змінні
            error_vars = function.free_symbols - {x_symbol} # з введених змінних прибираємо х
            if error_vars: # якщо ще є символьні змінні окрім х
                print(f"Помилка! У функції знайдено невідомі змінні: {error_vars}")
                print("Дозволено використовувати лише змінну 'x'")
                continue

            f = sp.lambdify(x_symbol, function, 'numpy') # створюємо функцію для обчислень

            break

        except Exception as e: # якщо виникла помилка
            print(f"Помилка при введенні функції: {e}")

    while True: # введення нижньої межі інтегрування
        try: # спробуємо виконати наступний блок коду
            a = float(input("Введіть нижню межу інтегрування a: "))
            break
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    while True: # введення верхньої межі інтегрування
        try: # спробуємо виконати наступний блок коду
            b = float(input("Введіть верхню межу інтегрування b: "))

            if a >= b:
                print("Помилка! b повинно бути більше за a")
            else:
                break
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    while True: # введення точності обчислень е
        try: # спробуємо виконати наступний блок коду
            epsilon = float(input("Введіть точність обчислень e: "))

            if epsilon <= 0 or epsilon >= 1:
                print("Помилка! Значення e введено не правильно")
            else:
                break
        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть число")

    n = 2 # початкова кількість відрізків (на скільки частин поділено відрізок ab)
    s_previous = None # попереднє значення формули Сімпсона

    while True: # поки не спрацює break
        h = (b - a) / n # обчислюємо крок

        x_arr = [] # оголошуємо масив який зберігатиме значення точок по х
        y_arr = [] # оголошуємо масив який зберігатиме значення точок по у

        for i in range(0, n + 1): # цикл для знаходження точок розбиття
            x_t = a + i * h # знаходження точки розбиття

            try: # спробуємо обчислити значення функції в знайденому х
                y_t = f(x_t)
            except Exception as err: # якщо виникла помилка
                print(f"Помилка при обчисленні значень функції: {err}")
                return # аварійно завершуємо функцію

            x_arr.append(x_t) # додаємо обчислене значення х
            y_arr.append(y_t) # додаємо обчислене значення у

        s_current = simpson(h, y_arr) # отримаємо наближений розв'язок за формулою Сімпсона

        if s_previous is not None: # якщо попередньо обчислене значення існує
            print(f"\nПеревіримо отримане значення інтеграла ({s_previous:.4f}) на точність розрахунків:")
            print(f"    Застосуємо правило Рунге")

            R = abs(s_current - s_previous) / 15 # оцінюємо похибку

            print(f"    Значення інтеграла при n = {n} дорівнює {s_current:.4f} ")
            print(f"    Похибка = |{s_current:.4f} - {s_previous:.4f}| / 15 = {R:.8f}")

            if R <= epsilon: # якщо шукану точність знайдено
                print(f"\nДосягнуто заданої точності e = {epsilon:.8f}!")
                print(f"Кінцевий результат: {s_previous:.4f}\nПохибка = {R:.8f}\nm = {n/4}\nn = {n/2}\nh = {h*2}")
                break
            else:
                print(f"\nЗаданої точності e = {epsilon:.8f} не досягнуто")
                print(f"Перейдемо до значення інтеграла при n = {n}")
        else:
            print(f"\nЗначення інтеграла при n = {n} дорівнює {s_current:.4f}")

        # готуємось до наступної ітерації
        s_previous = s_current
        n *= 2

main() # виклик головної функції програми
