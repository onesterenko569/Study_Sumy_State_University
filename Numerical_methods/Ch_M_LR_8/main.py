import sympy as sp
import numpy as np
import matplotlib.pyplot as plt

# функція перетворення введеного тексту користувачем у функцію
def input_math_function(text): # приймає текст
    x = sp.symbols('x')        # створюємо математичний символ х

    while True: # цикл, який триватиме до моменту правильного вводу користувачем
        try:    # спробуємо виконати наступний блок коду
            user_input = input(text).strip()      # користувач вводить функцію
            if not user_input:                    # якщо користувач нічого не ввів
                print("   Помилка! Введіть функцію") # виведення відповідного повідомлення про помилку
                continue                          # розпочинаємо наступну ітерацію циклу

            # перетворюємо введений рядок у символьний математичний вираз
            symb_math_expr = sp.sympify(user_input, locals={'x': x})

            if not symb_math_expr.free_symbols.issubset({x}):            # перевірка чи не ввів користувач щось окрім х
                print("   Помилка! Вираз повинен містити лише змінну x") # виведення відповідного повідомлення
                continue                                                 # розпочинаємо наступну ітерацію циклу

            # перетворюємо введений рядок у функцію
            fun = sp.lambdify(x, symb_math_expr, 'numpy')

            return symb_math_expr, fun # повертаємо символьний математичний вираз та функцію

        except Exception as e: # якщо виникла помилка при введені функції
            print(f"   Помилка! Некоректне введення. Спробуйте ще раз") # виведення відповідного повідомлення

# функція для введення alpha1, alpha2...
def input_coefficient(text): # приймає текст
    while True: # цикл, який триватиме до моменту правильного вводу користувачем
        try:    # спробуємо виконати наступний блок коду
            coef = float(input(text)) # введення числа
            break                     # якщо все добре, завершуємо цикл
        except ValueError: # якщо виникла помилка при введенні
            print("   Помилка! Введіть число") # відповідне повідомлення про помилку

    return coef # повертаємо введений коефіцієнт

# функція реалізації методу скінченних різниць
def finite_difference_method(n, a, b, p_fun, q_fun, f_fun, alpha1, alpha2, A, beta1, beta2, B):
    h = (b - a) / n              # розраховуємо крок сітки
    x = np.linspace(a, b, n + 1) # створюємо масив із n + 1 точок від a до b

    ai = np.zeros(n + 1)         # створюємо масив ai заповнений нулями та розмірністю n + 1
    bi = np.zeros(n + 1)         # створюємо масив bi заповнений нулями та розмірністю n + 1
    ci = np.zeros(n + 1)         # створюємо масив ci заповнений нулями та розмірністю n + 1
    di = np.zeros(n + 1)         # створюємо масив di заповнений нулями та розмірністю n + 1

    # розраховуємо значення для лівої межі відрізка
    bi[0] = h * alpha1 - alpha2  # розрахунок b0 за формулою
    ci[0] = alpha2               # розрахунок c0 за формулою
    di[0] = h * A                # розрахунок d0 за формулою

    # розраховуємо значення для внутрішніх точок відрізка [a, b]
    for i in range(1, n):        # цикл по внутрішнім точкам
        p_val = p_fun(x[i])      # значення p(x) у поточній точці
        q_val = q_fun(x[i])      # значення q(x) у поточній точці
        f_val = f_fun(x[i])      # значення f(x) у поточній точці

        ai[i] = 1 - (h * p_val) / 2  # розрахунок ai за формулою
        bi[i] = h ** 2 * q_val - 2   # розрахунок bi за формулою
        ci[i] = 1 + (h * p_val) / 2  # розрахунок ci за формулою
        di[i] = h ** 2 * f_val       # розрахунок di за формулою

    # розраховуємо значення для правої межі відрізка
    ai[n] = -beta2                   # розрахунок an за формулою
    bi[n] = h * beta1 + beta2        # розрахунок bn за формулою
    di[n] = h * B                    # розрахунок dn за формулою

    # метод прогонки
    s = np.zeros(n)  # створюємо масив s заповнений нулями та розмірністю n
    t = np.zeros(n)  # створюємо масив t заповнений нулями та розмірністю n

    s[0] = -ci[0] / bi[0] # розраховуємо s для початкової точки
    t[0] = di[0] / bi[0]  # розраховуємо t для початкової точки

    for i in range(1, n): # цикл для обрахунку s, t від другої точки
        s[i] = (-ci[i]) / (bi[i] + ai[i] * s[i - 1])                   # розраховуємо s
        t[i] = (di[i] - ai[i] * t[i - 1]) / (bi[i] + ai[i] * s[i - 1]) # розраховуємо t

    # зворотний хід
    y = np.zeros(n + 1) # створюємо масив y заповнений нулями та розмірністю n + 1
    y[n] = (di[n] - ai[n] * t[n - 1]) / (bi[n] + ai[n] * s[n - 1])     # розрахунок y для останньої точки x

    for i in range(n - 1, -1, -1):     # цикл для розрахунку інших значень y
        y[i] = s[i] * y[i + 1] + t[i]  # розрахунок

    return x, y # повертаємо розраховані масиви x та y

def main(): # головна функція програми
    print("Введення даних для крайової задачі")

    # введення p(x), q(x) та f(x)
    print("\nВведіть необхідні дані для диференціального рівняння виду y'' + p(x)y' + q(x)y = f(x):")
    p_expr, p_fun = input_math_function("   p(x) = ")
    q_expr, q_fun = input_math_function("   q(x) = ")
    f_expr, f_fun = input_math_function("   f(x) = ")

    # введення alpha1, alpha2 та A
    print("\nВведіть крайову умову в точці x = a виду alpha1 * y(a) + alpha2 * y'(a) = A")
    alpha1 = input_coefficient("   alpha1 = ")
    alpha2 = input_coefficient("   alpha2 = ")
    A = input_coefficient("   A = ")

    # введення beta1, beta2 та B
    print("\nВведіть крайову умову в точці x = b виду beta1 * y(b) + beta2 * y'(b) = B")
    beta1 = input_coefficient("   beta1 = ")
    beta2 = input_coefficient("   beta2 = ")
    B = input_coefficient("   B = ")

    # введення лівої межі відрізка [a, b]
    print("\nВведіть інтервал розв’язку [a, b]:")
    a = input_coefficient("   a = ")

    # введення правої межі відрізка [a, b]
    while True: # цикл, який триватиме до моменту правильного вводу користувачем
        b = input_coefficient("   b = ")  # введення правої межі відрізка [a, b]

        if a >= b: # якщо введено не правильно
            print("   Помилка! b повинно бути більше за a") # повідомлення про помилку
            continue # розпочинаємо наступну ітерацію циклу

        else: # якщо введено правильно
            break # завершуємо цикл

    # введення кількості відрізків розбиття відрізку [a, b]
    print("\nВведіть параметри чисельного методу:")
    while True: # цикл, який триватиме до моменту правильного вводу користувачем
        try:    # спробуємо виконати наступний блок коду
            n = int(input(f"   Кількість відрізків розбиття проміжку [{a}, {b}] n = ")) # введення кількості відрізків розбиття
            if n <= 0: # перевірка на правильність вводу
                print("   Помилка! n повинно бути додатним") # виведення відповідного повідомлення
                continue # розпочинаємо наступну ітерацію циклу

            else: # якщо все введено правильно
                break # завершуємо цикл

        except ValueError: # якщо виникла помилка при введенні
            print("   Помилка! Введіть ціле число") # відповідне повідомлення про помилку

    while True: # введення точності обчислень е
        try: # спробуємо виконати наступний блок коду
            epsilon = float(input("   Точність обчислень e = "))

            if epsilon <= 0 or epsilon >= 1: # якщо введено не правильно
                print("   Помилка! Значення e введено не правильно")
            else: # якщо введено правильно
                break # зупиняємо цикл

        except ValueError: # якщо виникла помилка
            print("   Помилка! Введіть число")

    # виводимо сформовану крайову задачу на екран
    print(f"\nСформована крайова задача, яку необхідно розв'язати з точністю e = {epsilon:.4f}:")

    # зберігаємо в інші змінні типом float, щоб при виведенні крайової задачі не виводились занадто довгі числа
    f_display = float(f_expr) if f_expr.is_number else f_expr
    p_display = float(p_expr) if p_expr.is_number else p_expr
    q_display = float(q_expr) if q_expr.is_number else q_expr

    # виведення крайової задачі
    print(f" / y'' + ({p_display}) * y' + ({q_display}) * y = {f_display}")
    print(f" |\n<  {alpha1} * y({a}) + ({alpha2}) * y'({a}) = {A}")
    print(f" |\n \\ {beta1} * y({b}) + ({beta2}) * y'({b}) = {B}")

    # перевірка за правилом Рунге
    n_curr = n  # створюємо робочу змінну, яку потім будемо змінювати
    while True: # цикл, який працюватиме до тих пір, поки ми не досягнемо потрібної точності
        # розв'язок з кроком h
        x_h, y_h = finite_difference_method(n_curr, a, b, p_fun, q_fun, f_fun, alpha1, alpha2, A, beta1, beta2, B)

        # розв'язок з кроком h/2
        n_double = n_curr * 2  # збільшуємо кількість відрізків розбиття вдвічі
        x_h2, y_h2 = finite_difference_method(n_double, a, b, p_fun, q_fun, f_fun, alpha1, alpha2, A, beta1, beta2, B)

        max_error = 0       # ініціалізуємо змінну для пошуку найбільшої похибки серед усіх точок
        current_errors = [] # ініціалізуємо список, куди ми будемо записувати похибку для кожної точки

        for i in range(n_curr + 1): # цикл по всіх точках з кроком h
            error = abs(y_h2[i * 2] - y_h[i]) / 3.0  # застосовуємо правило Рунге
            current_errors.append(error)             # зберігаємо похибку для поточної точки

            if error > max_error:   # якщо було знайдено більшу похибку
                max_error = error   # запам'ятовуємо найбільшу похибку

        if max_error <= epsilon: # якщо необхідної точності досягнуто
            final_x = x_h                 # зберігаємо фінальний масив х
            final_y = y_h                 # зберігаємо фінальний масив у
            final_errors = current_errors # зберігаємо фінальний масив похибок
            final_h = (b - a) / n_curr    # розраховуємо крок з яким було знайдено розв'язок з необхідною точністю

            break                         # завершуємо цикл

        else: # якщо необхідної точності було не досягнуто
            n_curr *= 2  # подвоюємо кількість розбиттів
            if n_curr > 1000000: # захист від нескінченного циклу
                print("Досягнуто ліміт ітерацій!") # виведення відповідного повідомлення
                final_x, final_y, final_errors = x_h, y_h, current_errors # зберігаємо значення на останній ітерації
                final_n, final_h = n_curr, (b - a) / n_curr               # зберігаємо значення на останній ітерації

                break # завершуємо цикл

    # виведення результатів
    print(f"\nРозв'язок успішно знайдено з заданою точністю e = {epsilon} та кроком розбиття {final_h:.5f}")

    # друкуємо заголовок таблиці
    print(f"\n    x    |      y      |   Похибка")
    print("-------------------------------------")

    k = n_curr // n # розраховуємо у скільки разів фінальна сітка стала густішою за початкову

    for i in range(0, n_curr + 1, k): # цикл для виведення результатів обчислень
        print(f"   {final_x[i]:.1f}   |   {final_y[i]:.5f}   |  {final_errors[i]:.2e}")

    # побудова точкового графіка
    plt.figure(figsize=(8, 6)) # задаємо розмір вікна з графіком

    # будуємо точковий графік
    plt.plot(final_x, final_y, 'bo', markersize=5, label='Вузли сітки')

    plt.xlabel("x")    # підписуємо вісь абсцис
    plt.ylabel("y(x)") # підписуємо вісь ординат
    plt.title("Точковий графік")                     # підписуємо вікно графіка
    plt.grid(True, linestyle='--', alpha=0.6) # додаємо сітку
    plt.legend() # показуємо легенду

    plt.show() # відображаємо графік на екрані

main() # виклик головной функції програми