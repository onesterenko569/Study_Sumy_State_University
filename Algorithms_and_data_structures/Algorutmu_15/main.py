import random

# цільова функція
def f(x1, x2):
    return (x1 - 2)**2 + (x2 - 2)**2

# функція для перевірки обмежень
def violations(x1, x2):
    v = 0.0                              # зберігатиме сумарне порушення обмежень (0 якщо все ок)

    v += max(0.0, (2*x1 + x2) - 10)      # якщо ліва частина 1 обмеження <= 10, то порушення 0, якщо більше то порушення = (2*x1 + x2) - 10
    v += max(0.0, (-2*x1 + 3*x2) - 6)    # якщо ліва частина 2 обмеження <= 6, то порушення 0, якщо більше то порушення = (-2*x1 + 3*x2) - 6
    v += max(0.0, 8 - (2*x1 + 4*x2))     # якщо 2*x1 + 4*x2 >= 8, то порушення 0, якщо < 8 то порушення = 8 - (2*x1 + 4*x2)
    v += max(0.0, -x1)                   # якщо x1 >= 0 то порушення дає 0, якщо x1 < 0 то порушення -x1
    v += max(0.0, -x2)                   # якщо x2 >= 0 то порушення дає 0, якщо x2 < 0 то порушення -x2

    return v                             # повертаємо суму порушень

# функція перевірки допустимості
def feasible(x1, x2):
    return violations(x1, x2) < 1e-9     # якщо violations(x1, x2) < 1e-9 то повертає True, інакше False

# функція для того щоб x1, x2 не виходили за межі a та b
def clip(x, a, b):
    if x < a: return a   # якщо x менше нижньої межі a, повертає a
    if x > b: return b   # якщо x більше верхньої межі b, повертає b
    return x             # інакше повертає x

# межі для генерації
X1_MIN, X1_MAX = 0.0, 5.0 # для х1 нижня межа 0, а верхня 5
X2_MIN, X2_MAX = 0.0, 5.0 # для х2 нижня межа 0, а верхня 5

# функція створення випадкового індивіда
def random_ind():
    # генеруємо випадкові числа між X1_MIN, X1_MAX та X2_MIN, X2_MAX
    return [random.uniform(X1_MIN, X1_MAX), random.uniform(X2_MIN, X2_MAX)]

# функція перевірки наскільки особина хороша
def score(ind, mode, W=10000.0):
    x1, x2 = ind[0], ind[1]      # витягуємо координати

    # обраховуємо штраф, якщо порушень немає то штраф 0, в іншому випадку W * violations(x1, x2)
    pen = W * violations(x1, x2)

    val = f(x1, x2)        # обраховуємо значення цільової функції

    if mode == "min":      # якщо шукаємо мінімум
        return -val - pen  # віднімаємо штраф

    else:                  # якщо шукаємо максимум
        return  val - pen  # віднімаємо штраф

# функція обрання батьків для схрещування
def tournament(pop, scores, k=3):  # pop - список особин (популяція), scores - оцінка для кожної особини, k - скільки учасників беремо випадково
    best = None            # індекс для зберігання найкращої особини
    for _ in range(k):     # запускаємо цикл k разів
        i = random.randrange(len(pop))  # вибираємо випадковий індекс особини з популяції

        if best is None or scores[i] > scores[best]: # якщо ми ще нікого не обрали або оцінка поточного кандидата краща, ніж у того, хто поки що вважається best
            best = i     # зберігаємо індекс i як нового найкращого серед уже вибраних

    return pop[best][:]  # повертаємо копію особини, яка виграла турнір

# функція схрещування
def crossover(p1, p2):  # p1, p2 - два батьки

    a = random.random() # випадкове дійсне число між 0 і 1 (коефіцієнт змішування батьків)

    c1 = [a*p1[0] + (1-a)*p2[0], a*p1[1] + (1-a)*p2[1]] # перша дитина
    c2 = [a*p2[0] + (1-a)*p1[0], a*p2[1] + (1-a)*p1[1]] # друга дитина

    return c1, c2 # повертаємо дітей

# функція мутації
def mutate(ind, p=0.2, sigma=0.25): # ind - індивід (особина), p - ймовірність мутації для кожного гена, sigma - сила мутації

    if random.random() < p: # якщо випадкове число менше на 0.2
        ind[0] += random.gauss(0, sigma) # додаємо до гену випадкове число від -sigma до sigma

    if random.random() < p: # якщо випадкове число менше на 0.2
        ind[1] += random.gauss(0, sigma) # додаємо до гену випадкове число від -sigma до sigma

    # якщо після мутації гени вилетіли за межі, то обрізаємо
    ind[0] = clip(ind[0], X1_MIN, X1_MAX)
    ind[1] = clip(ind[1], X2_MIN, X2_MAX)

    return ind # повертаємо зміненого індивіда

# функція генетичного алгоритму, який по кроках створює популяції, відбирає кращих, робить схрещування і мутації
def genetic(mode, pop_size=300, generations=600, elite=8, p_cross=0.9, p_mut=0.2, seed=42):
    random.seed(seed) # фіксує генератор випадкових чисел

    pop = [random_ind() for _ in range(pop_size)] # створюємо початкову популяцію

    best_ind = pop[0][:]            # найкращий індивід, який ми знайшли за весь час (спочатку перший індивід з популяції)
    best_sc = score(best_ind, mode) # рахуємо якість для best_ind

    for _ in range(generations): # основний цикл по поколіннях
        sc = [score(ind, mode) for ind in pop] # рахуємо оцінку для кожної особини у популяції

        # оновлюємо глобально найкращого індивідума
        i_best = max(range(pop_size), key=lambda i: sc[i]) # шукаємо індекс найкращої особини в поточному поколінні
        if sc[i_best] > best_sc:      # якщо найкраща особина в цьому поколінні краща за глобально найкращу
            best_sc = sc[i_best]      # оновлюємо best_sc
            best_ind = pop[i_best][:] # зберігаємо копію найкращого індивіда як best_ind

        # сортуємо індекси всіх особин за оцінкою score від найбільшого до найменшого
        ids = sorted(range(pop_size), key=lambda i: sc[i], reverse=True)

        # створюємо нову популяцію new_pop і одразу додаємо туди найкращих особин
        new_pop = [pop[i][:] for i in ids[:elite]]

        # формування решти нового покоління
        while len(new_pop) < pop_size:    # поки нова популяція не заповнена до pop_size

            # обираємо двох батьків турнірним відбором (беремо 3 випадкових особини і вибираємо найкращу з них)
            p1 = tournament(pop, sc, k=3)
            p2 = tournament(pop, sc, k=3)

            if random.random() < p_cross:  # з ймовірністю p_cross
                c1, c2 = crossover(p1, p2) # схрещуємо і отримуємо 2 дітей c1, c2

            else: # інакше (10% випадків)
                c1, c2 = p1[:], p2[:] # беремо копії батьків

            new_pop.append(mutate(c1, p=p_mut)) # мутуємо c1 з ймовірністю p_mut
            if len(new_pop) < pop_size: # якщо в популяції ще є місце
                new_pop.append(mutate(c2, p=p_mut)) # додаємо другого мутованого нащадка

        pop = new_pop

    x1, x2 = best_ind[0], best_ind[1]
    return x1, x2, f(x1, x2), feasible(x1, x2), violations(x1, x2)

def main():
    x1, x2, val, ok, v = genetic("min", seed=42)
    print("Цільова функція:")
    print("   f=(x1-2)^2+(x2-2)^2")
    print("\nОбмеження:\n   2x1+x2<=10;\n   -2x1+3x2<=6;\n   2x1+4x2>=8;\n   x1>=0;\n   x2>=0.\n")

    print("Мінімум:")
    print("\n   x1 =", round(x1, 6), "\n   x2 =", round(x2, 6))
    print("   f =", round(val, 10))
    print("   Чи не вилізли за обмеження:", ok, "\n   Наскільки вилізли за обмеження:", format(v, ".3e"), "\n")

    x1, x2, val, ok, v = genetic("max", seed=42)
    print("Максимум")
    print("\n   x1 =", round(x1, 6), "\n   x2 =", round(x2, 6))
    print("   f =", round(val, 10))
    print("   Чи не вилізли за обмеження:", ok, "\n   Наскільки вилізли за обмеження:", format(v, ".3e"))

main()
