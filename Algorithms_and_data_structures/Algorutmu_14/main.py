# введення розмірності матриці
while True: # цикл триватиме, поки користувач правильно введе розмірність матриці
    try:    # спробуємо виконати наступний блок коду
        n = int(input("Введіть розмірність квадратної матриці n: ")) # користувач вводить розмірність матриці
        if n < 2: # якщо введено не правильно
            print("Введено не правильно")
            continue # продовжуємо наступну ітерацію циклу
        else: # якщо введено правильно
            break # зупиняємо цикл
    except ValueError: # якщо виникла помилка
        print("Помилка! Введіть ціле число") # виведення відповідного повідомлення

matrix = [] # змінна яка зберігатиме матрицю

# введення матриці
print(f"Введіть матрицю призів ({n} рядків по {n} чисел, зверху вниз):")
while True: # цикл триватиме, поки користувач правильно введе розмірність матриці
    try:    # спробуємо виконати наступний блок коду
        matrix = []  # очищаємо матрицю
        for i in range(n): # цикл по рядкам
            row = list(map(int, input(f"Рядок {i + 1}: ").split())) # користувач вводить рядок матриці
            while len(row) != n: # якщо к-сть елементів не = n
                print("Помилка! Потрібно ввести рівно", n, "чисел") # виведення відповідної помилки
                row = list(map(int, input(f"Рядок {i + 1}: ").split())) # повторне введення
            matrix.append(row) # додаємо введений рядок до матриці

        break # зупиняємо цикл

    except ValueError: # якщо виникла помилка
        print("Помилка! У рядку мають бути лише цілі числа") # виведення відповідного повідомлення

# ЗВОРОТНІЙ ХІД

# ініціалізація масиву для зворотно ходу
F = [[0] * n for _ in range(n)]

# зберігаємо значення правого верхнього кута матриці
F[0][n - 1] = matrix[0][n - 1]

# обраховуємо верхній рядок
for j in range(n - 2, -1, -1):
    F[0][j] = matrix[0][j] + F[0][j + 1]

# обраховуємо крайній правий стовпчик
for i in range(1, n):
    F[i][n - 1] = matrix[i][n - 1] + F[i - 1][n - 1]

# обраховуємо внутрішні клітинки
for i in range(1, n):               # цикл по рядкам
    for j in range(n - 2, -1, -1):  # цикл по стовпцях
        F[i][j] = matrix[i][j] + max(
            F[i][j + 1],      # вправо
            F[i - 1][j],      # вгору
            F[i - 1][j + 1]   # діагональ
        )

# ПРЯМИЙ ХІД
path = [] # масив який буде зберігати оптимальний шлях мандрівника
i, j = n - 1, 0  # старт: нижній лівий кут

while True: # цикл триватиме, поки не спрацює break
    path.append((i, j)) # додаємо поточну координату

    if i == 0 and j == n - 1: # якщо дійшли до правої верхньої координати
        break                 # зупиняємо цикл

    moves = [] # масив для збереження всіх можливих наступних ходів з поточної клітинки

    if j + 1 < n: # якщо не дійшли до правого краю матриці
        moves.append((F[i][j + 1], i, j + 1)) # додаємо можливий хід направо

    if i - 1 >= 0: # якщо не дійшли до верхнього краю матриці
        moves.append((F[i - 1][j], i - 1, j)) # додаємо можливий хід вгору

    if i - 1 >= 0 and j + 1 < n: # якщо не дійшли до верхнього краю матриці та правого краю матриці
        moves.append((F[i - 1][j + 1], i - 1, j + 1)) # додаємо можливий хід по діагоналі

    _, i, j = max(moves, key=lambda x: x[0])

# НУМЕРАЦІЯ КРОКІВ
steps = [["." for _ in range(n)] for _ in range(n)]

for step, (r, c) in enumerate(path, start=1):
    steps[r][c] = str(step)

# ВИВЕДЕННЯ РЕЗУЛЬТАТІВ
print("\nВведена матриця:")
for row in matrix:
    print(" ".join(f"{x:4d}" for x in row))

print("\nРезультат зворотнього ходу:")
for row in F:
    print(" ".join(f"{x:4d}" for x in row))

print("\nНумерація кроків оптимального маршруту:")
for row in steps:
    print(" ".join(f"{x:>4}" for x in row))

print(f"\nМаксимальний приз: {F[n - 1][0]}")

print("\nОптимальний шлях (у шахових координатах):")
for r, c in path:
    print(f"({n - r},{c + 1})", end=" ")
