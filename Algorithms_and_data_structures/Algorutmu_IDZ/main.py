import time
import math
import random

# функція для знаходження кореневих вершин
def find_set(parent, i, oper_count):
    oper_count[0] += 1                           # збільшуємо кількість операцій порівнянь
    if parent[i] == i:                           # якщо у вершини немає батька
        return i                                 # повертаємо знайдений корінь дерева

    oper_count[0] += 1                           # збільшуємо кількість операцій присвоєння
    parent[i] = find_set(parent, parent[i], oper_count) # рекурсивний виклик для знаходження кореня дерева
    return parent[i]                             # повертаємо знайдений корінь

# реалізовує об'єднання вершин, множин
def union_sets(parent, rank, u, v, oper_count):
    root_u = find_set(parent, u, oper_count)      # отримуємо кореневу вершину для вершини u
    root_v = find_set(parent, v, oper_count)      # отримуємо кореневу вершину для вершини v
    oper_count[0] += 2                            # збільшуємо кількість операцій присвоєння

    oper_count[0] += 1                            # збільшуємо кількість операцій порівнянь
    if root_u != root_v:                          # якщо кореневі вершини для u та v різні
        oper_count[0] += 1                        # збільшуємо кількість операцій порівнянь

        if rank[root_u] < rank[root_v]:           # якщо дерево вершини u менше за дерево вершини v
            parent[root_u] = root_v               # додаємо менше дерево знизу до великого дерева
            oper_count[0] += 1                    # збільшуємо кількість операцій присвоєння

        elif rank[root_u] > rank[root_v]:         # якщо дерево вершини v менше за дерево вершини u
            oper_count[0] += 1                    # збільшуємо кількість операцій порівнянь
            parent[root_v] = root_u               # додаємо менше дерево знизу до великого дерева
            oper_count[0] += 1                    # збільшуємо кількість операцій присвоєння

        else:                                     # якщо дерева однакової висоти
            oper_count[0] += 1                    # збільшуємо кількість операцій порівнянь
            parent[root_v] = root_u               # додаємо дерево знизу до іншого дерева
            rank[root_u] += 1                     # збільшуємо висоту дерева
            oper_count[0] += 2                    # збільшуємо кількість операцій присвоєння

        return True                               # об'єднання відбулося успішно

    return False # якщо кореневі вершини для u та v однакові, бо додавання ще одного ребра створить цикл

# функція реалізації алгоритму Крускала
def algorithm_kruskal(n, edges_kruskal):       # приймає кількість вершин та список усіх ребер (список, елементами якого є кортежі)
    oper_count = [0]                           # створюємо лічильник операцій
    start_time = time.perf_counter()           # засікаємо час початку
    mst_weight = 0                             # сюди будемо додавати вагу обраних ребер
    mst_edges = []                             # сюди будемо складати самі ребра, які увійшли в остове дерево

    edges_kruskal.sort(key=lambda x: x[2])     # сортуємо список ребер за їх вагою у порядку зростання
    num_edges = len(edges_kruskal)             # підраховуємо кількість ребер
    if num_edges > 1:                          # якщо ребер більше ніж 1
        oper_count[0] += int(num_edges * math.log2(num_edges)) # підраховуємо кількість операцій

    parent = [0] * n                           # масив батьків, і - відповідає номеру вершини, а parent[i] - вказує на батька цієї вершини
    rank = [0] * n                             # список, де записано висоту підпорядкування, і - відповідає номеру вершини, а rank[і] - скільки рівнів дерева під і-тою вершиною

    # виконуємо стартову ініціалізацію
    for i in range(n):
        parent[i] = i                          # кожна вершина сам собі батько
        rank[i] = 0                            # кожна вершина не має дітей
        oper_count[0] += 2                     # збільшуємо кількість операцій присвоєння

    # йдемо по вже відсортованому списку, першим беремо ребро з найменшою вагою
    for u, v, w in edges_kruskal:
        oper_count[0] += 3                     # збільшуємо кількість операцій присвоєння

        if union_sets(parent, rank, u, v, oper_count): # якщо ребро (u, v) не створює цикл (якщо різні кореневі вершини)
            mst_weight += w                    # додаємо вагу ребра до загальної суми
            mst_edges.append((u, v, w))        # зберігаємо ребро в список результатів
            oper_count[0] += 2                 # збільшуємо кількість операцій присвоєння

    end_time = time.perf_counter()             # фіксуємо час завершення
    return mst_weight, mst_edges, end_time - start_time, oper_count[0] # повертаємо всі результати

# функція реалізації алгоритму Прима з матрицею суміжності
def algorithm_prim_matrix(n, adj_matrix):
    oper_count = [0]                 # ініціалізуємо лічильник операцій
    start_time = time.perf_counter() # засікаємо час початку

    INF = math.inf           # визначаємо математичну нескінченність

    key = [INF] * n          # масив мінімальних ваг приєднання вершин до MST, де і - вершина, key[i] - вага найкоротшого ребра, яке з'єднує вершину i з MST
    parent = [-1] * n        # масив, який показує з якої вершини ми найвигідніше приєднуємо вершину i в MST (parent[5] = 2 - вершину 5 приєднали до MST від вершини 2)
    used = [False] * n       # щоб знати, які вершини ми вже додали до остового дерева, а які ні
    oper_count[0] += 3 * n   # збільшуємо лічильник операцій

    key[0] = 0               # починаємо з нульової вершини
    oper_count[0] += 1       # збільшуємо лічильник операцій

    # цикл робить максимум n додавань вершин у MST (додає кожну вершину)
    for _ in range(n): # цикл по всіх вершинах
        v = -1         # змінна для збереження індексу вершини яку найраще додати до MST
        oper_count[0] += 2         # збільшуємо лічильник операцій

        for i in range(n):         # цикл знаходження вершини v, яку найкраще додати в MST
            oper_count[0] += 2     # збільшуємо лічильник операцій

            if (not used[i]) and (v == -1 or key[i] < key[v]): # вершина яка ще не в MST та має найменший key[i] (найм. відстань до MST)
                v = i                                          # оновлення кандидата
                oper_count[0] += 1                             # збільшуємо лічильник операцій

        oper_count[0] += 1           # збільшуємо лічильник операцій
        if v == -1 or key[v] == INF: # якщо граф не зв'язний
            break                    # виходимо з циклу

        used[v] = True               # додаємо вершину v в MST
        oper_count[0] += 1           # збільшуємо лічильник операцій

        # оновлюємо масиви key та parent для сусідів після того як було додано вершину v до MST
        for to in range(n):
            w = adj_matrix[v][to]                # зберігаємо вагу ребра від доданої до MST вершини v до вершини to
            oper_count[0] += 1                   # збільшуємо лічильник операцій

            oper_count[0] += 2                   # збільшуємо лічильник операцій
            if (not used[to]) and (w != INF) and (w < key[to]): # якщо вершина to не в MST і ребро з v до to дає менше приєднання до MST ніж те, що було раніше
                key[to] = w                      # оновлюємо вагу найменшого ребра від вершини to до MST
                parent[to] = v                   # зберігаємо що вершину to найкраще додавати до MST через вершину v
                oper_count[0] += 2               # збільшуємо лічильник операцій

    mst_edges = []   # список ребер, які додано до MST
    mst_weight = 0   # змінна для збереження ваги остового дерева

    # цикл формування списку ребер MST
    for v in range(1, n):
        oper_count[0] += 1           # збільшуємо лічильник операцій

        # якщо вершина v була приєднана до MST і відстань від v до parent[v] != нескінченності
        if parent[v] != -1 and adj_matrix[parent[v]][v] != INF:
            w = adj_matrix[parent[v]][v]          # дістаємо вагу ребра, яким v приєднали до MST
            mst_edges.append((parent[v], v, w))   # додаємо ребро в список MST (звідки, куди, вага)
            mst_weight += w                       # підраховуємо вагу остового дерева
            oper_count[0] += 3                    # збільшуємо лічильник операцій

    end_time = time.perf_counter()                                     # фіксуємо час завершення
    return mst_weight, mst_edges, end_time - start_time, oper_count[0] # повертаємо всі результати

# функція для генерації випадкового зв’язного неорієнтованого зваженого графа заданої щільності
def generate_connected_weighted_undirected_graph_matrix(n, density, w_min=1, w_max=20, seed=None):
    if seed is not None:  # якщо seed не None
        random.seed(seed) # отримуватимемо однакові графи для однакових параметрів

    INF = math.inf                             # визначаємо математичну нескінченність
    adj_matrix = [[INF] * n for _ in range(n)] # робимо матрицю n * n, де всюди INF (нескінченність)

    # на діагоналі матриці ставимо 0
    for i in range(n):
        adj_matrix[i][i] = 0

    if n <= 1:                 # якщо 1 вершина, або менше, то ребер бути не може
        return [], adj_matrix  # повертаємо пусті списки

    max_edges = n * (n - 1) // 2                    # обчислюємо максимум ребер у неорієнтованому простому графі

    target_m = int(round(density * max_edges))      # розраховуємо кількість ребер згідно densit (щільності)
    target_m = max(n - 1, min(max_edges, target_m)) # не дозволяємо ребер менше, ніж n-1 та більше, ніж максимум (щоб не вилізти за обмеження)

    edges_set = set()       # множина для перевірки унікальності (зберігаються тільки пари вершин без ваги)
    edges_kruskal = []      # список ребер графа (звідки, куди, вага)

    # внутрішня функція для упорядкованості ребер
    def add_edge(u, v, w):
        a, b = (u, v) if u < v else (v, u)   # якщо дали (5, 2), перетворює в (2, 5)

        if (a, b) in edges_set:              # якщо ребро вже існує
            return False                     # повертаємо False

        edges_set.add((a, b))                # додаємо ребро в edges_set
        edges_kruskal.append((a, b, w))      # додаємо ребро в edges_kruskal

        # записуємо вагу в матрицю одразу в двох місцях
        adj_matrix[a][b] = w
        adj_matrix[b][a] = w

        return True                          # повертаємо True

    # робимо випадкове остовне дерево для зв’язності
    vertices = list(range(n))  # створюємо список усіх вершин майбутнього графа
    random.shuffle(vertices)   # робимо порядок вершин випадковим

    for i in range(1, n):
        u = vertices[i]                           # зберігаємо вершину u
        v = vertices[random.randint(0, i - 1)] # під’єднуємо вершину u до якоїсь випадкової попередньої вершини
        w = random.randint(w_min, w_max)          # генеруємо випадкову вагу від w_min до w_max
        add_edge(u, v, w)                         # викликаємо функцію add_edge

    # додаємо випадкові ребра до потрібної щільності
    while len(edges_kruskal) < target_m: # поки кількість ребер в графі менша за бажану кількість
        u = random.randrange(n)          # випадково генеруємо u
        v = random.randrange(n)          # випадково генеруємо v

        if u == v:                       # якщо u та v однакові
            continue                     # розпочинаємо наступну ітерацію циклу

        w = random.randint(w_min, w_max) # генеруємо випадкову вагу від w_min до w_max
        add_edge(u, v, w)                # викликаємо функцію add_edge

    return edges_kruskal, adj_matrix     # повертаємо сформований список ребер для Крускала та створену матрицю для Прима

# головна функція програми
def main():
    print("____Порівняння алгоритмів Прима та Крускала____")

    while True: # цикл триватиме поки користувач не введе правильно
        try:    # спробуємо виконати наступний блок коду
            n = int(input("Введіть кількість вершин n: ")) # користувач вводить кількість вершин
            if n <= 0:                  # якщо кількість вершин менша за 0
                print("n має бути > 0") # виведення відповідного повідомлення
                continue                # розпочинаємо наступну ітерацію циклу

            break                       # якщо введено правильно, зупиняємо цикл

        except ValueError: # якщо виникла помилка
            print("Помилка! Введіть ціле число") # виведення відповідного повідомлення

    densities = [0.2, 0.5, 0.9] # задаємо щільність

    print("\nЩільності для тесту:", densities)

    for d in densities: # цикл по кожній щільності
        # генеруємо масиви для відповідної щільності
        edges_kruskal, adj_matrix = generate_connected_weighted_undirected_graph_matrix(n=n, density=d, w_min=1, w_max=50, seed=42)
        m = len(edges_kruskal) # підраховуємо кількість ребер

        w_p, mst_p, t_p, op_p = algorithm_prim_matrix(n, adj_matrix) # викликаємо функцію реалізації алгоритму Прима
        w_k, mst_k, t_k, op_k = algorithm_kruskal(n, edges_kruskal)  # викликаємо функцію реалізації алгоритму Крускала

        # виведення результатів
        print(f"\nДля щільності = {d:.2f}, кількості вершин n = {n} та кількості ребер m = {m}")
        print(f"   Алгоритм Прима:\n    Вага остового дерева = {w_p}\n    Час = {t_p:.6f} с\n    Кількість операцій = {op_p}")
        print(f"\n   Алгоритм Крускала:\n    Вага остового дерева = {w_k}\n    Час = {t_k:.6f} с\n    Кількість операцій = {op_k}")
        faster = "алгоритм Прима" if t_p < t_k else "алгоритм Крускала"
        print(f"\nШвидший: {faster}")

main() # виклик головної функції програми
