#include <stdio.h>
#include <stdlib.h> // підключення бібліотек
#include <time.h>

// структура для зберігання даних про сортування
typedef struct 
{
    long comp;                // кількість порівнянь
    long assig;               // кількість присвоєнь
    double time;              // тривалість виконання алгоритму в мілісекундах
} STATS;

// функція сортування вставками
void insertion_sort(int arr[], int n, STATS* stats) 
{
    int i, j, key;                    // оголошуємо необхідні змінні
    stats->comp = 0;                  // обнуляємо лічильник порівнянь
    stats->assig = 0;                 // обнуляємо лічильник присвоєнь

    clock_t start = clock();          // запам’ятовуємо початок виконання алгоритму

    for (i = 1; i < n; i++)           // основний цикл сортування
    {
        key = arr[i];                 // зберігаємо поточне значення яке потрібно вставити
        stats->assig++;               // збільшуємо кількість присвоєнь
        j = i - 1;                    // починаємо перевіряти елементи ліворуч від i

        while (j >= 0)                // рухаємося до початку масиву
        {
            stats->comp++;            // збільшуємо кількість порівнянь

            if (arr[j] > key)         // якщо поточний елемент більший за key
            {
                arr[j + 1] = arr[j];  // пересуваємо більший елемент праворуч
                stats->assig++;       // збільшуємо кількість присвоєнь
                j--;                  // переходимо до наступного елемента зліва
            }

            else                      // якщо поточний елемент менший або рівний key
            {
                break;                // виходимо з циклу
            }
        }
         
        arr[j + 1] = key;             // вставляємо key у знайдене місце
        stats->assig++;               // збільшуємо кількість присвоєнь
    }

    clock_t end = clock();                                         // коли весь масив відсортований зчитуємо кінцевий час
    stats->time = ((double)(end - start) / CLOCKS_PER_SEC) * 1000000; // обчислюємо час та переводимо його в мікросекунди
}

// функція для генерації випадкового, зростаючого та спадаючого масиву
void generate_array(int arr[], int n, int type) 
{
    if (type == 0)                     // якщо 0 створюємо випадковий масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = rand() % 10000;   // генеруємо випадковий масив від 0 до 9999
        }
    }
    else if (type == 1)                // якщо 1 створюємо зростаючий масив
    { 
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = i;                // генеруємо масив від 0 до n в порядку зростання
        }
    }
    else                               // якщо 2 створюємо спадний масив
    { 
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = n - i;            // генеруємо масив від n до 0 в порядку спадання
        }
    }
}

// функція перевірки правильності сортування масиву
int is_sorted(int arr[], int n) 
{
    for (int i = 0; i < n - 1; i++)   // проходимо по елементах масива
    {
        if (arr[i] > arr[i + 1])      // якщо не відсортовано
        {
            return 0;                 // повертаємо 0 - масив не відсортований
        }
    }
    return 1;                         // повертаємо 1 - масив відсортований
}

// головна функція програми
int main() 
{
    srand(time(NULL));                                                       // ініціалізація генератора випадкових чисел

    int sizes[] = { 10, 100, 1000, 5000, 10000 };                            // створюємо масив розмірів
    int num_sizes = sizeof(sizes) / sizeof(sizes[0]);                        // автоматично визначаємо кількість елементів у масиві sizes[] (20 / 4 = 5)

    const char* types[] = { "Vypadkove", "Zrostannya", "Spadannya" };        // масив назв типів послідовностей

    for (int s = 0; s < num_sizes; s++)                                      // зовнішній цикл по розмірах масиву
    {
        int n = sizes[s];                                                    // поточний розмір масиву для цього тесту
        for (int type = 0; type < 3; type++)                                 // внутрішній цикл по типах послідовності
        {
            int* arr = (int*)malloc(n * sizeof(int));                        // динамічно виділяємо пам’ять для масиву arr з n елементів
            if (!arr)                                                        // якщо пам'ять не виділено
            {
                printf("Pomylka vydilennya pam'yati!\n");                    // виведення відповідного повідомлення
                return 1;                                                    // завершуємо програму
            }

            generate_array(arr, n, type);                                    // генерація масиву потрібного типу
            STATS stats;                                                     // cтворення змінної для статистики
            insertion_sort(arr, n, &stats);                                  // сортуємо згенерований масив

            if (!is_sorted(arr, n))                                          // якщо відсортовано не правильно
            {
                printf("Masiv ne vidsortovanui!\n");                         // виведення відповідного повідомлення
            }
            
            printf("N = %-6d %-10s:       Chas vykonannya - %.0f mks       ",
                n, types[type], stats.time);
            printf("Poryvnyannya - %-8ld       Prysvoyennya - %-8ld\n",      // виведення результатів
                stats.comp, stats.assig);

            free(arr);                                                       // звільняємо пам'ять
        } 
        printf("\n");                                                        // відступ
    }

    return 0;                                                                // завершення програми
}
