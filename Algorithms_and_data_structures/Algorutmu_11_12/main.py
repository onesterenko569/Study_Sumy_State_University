import heapq # модуль для роботи з купою
import time  # модуль для роботи з часом
import math  # математичний модуль

# функція для знаходження кореневих вершин
def find_set(parent, i, oper_count):
    oper_count[0] += 1                                  # збільшуємо кількість операцій порівнянь
    if parent[i] == i:                           # якщо у вершини немає батька
        return i                                 # повертаємо знайдений корінь дерева

    oper_count[0] += 1                                  # збільшуємо кількість операцій присвоєння
    parent[i] = find_set(parent, parent[i], oper_count) # рекурсивний виклик для знаходження кореня дерева
    return parent[i]                             # повертаємо знайдений корінь

# реалізовує об'єднання вершин, множин
def union_sets(parent, rank, i, j, oper_count):
    root_i = find_set(parent, i, oper_count)      # отримуємо кореневу вершину для вершини і
    root_j = find_set(parent, j, oper_count)      # отримуємо кореневу вершину для вершини і
    oper_count[0] += 2                            # збільшуємо кількість операцій присвоєння

    oper_count[0] += 1                            # збільшуємо кількість операцій порівнянь
    if root_i != root_j:                   # якщо кореневі вершини для і та j різні
        oper_count[0] += 1                        # збільшуємо кількість операцій порівнянь

        if rank[root_i] < rank[root_j]:    # якщо дерево вершини i менше за дерево вершини j
            parent[root_i] = root_j        # додаємо менше дерево знизу до великого дерева
            oper_count[0] += 1                    # збільшуємо кількість операцій присвоєння

        elif rank[root_i] > rank[root_j]:  # якщо дерево вершини j менше за дерево вершини і
            oper_count[0] += 1                    # збільшуємо кількість операцій порівнянь
            parent[root_j] = root_i        # додаємо менше дерево знизу до великого дерева
            oper_count[0] += 1                    # збільшуємо кількість операцій присвоєння

        else:                              # якщо дерева однакової висоти
            oper_count[0] += 1                    # збільшуємо кількість операцій порівнянь
            parent[root_j] = root_i        # додаємо дерево знизу до іншого дерева
            rank[root_i] += 1              # збільшуємо висоту дерева
            oper_count[0] += 2                    # збільшуємо кількість операцій присвоєння

        return True                        # об'єднання відбулося успішно

    return False # якщо кореневі вершини для і та j однакові, бо додавання ще одного ребра створить цикл

# функція реалізації алгоритму Крускала
def algorithm_kruskal(n, edges):               # приймає кількість вершин та список усіх ребер (список, елементами якого є кортежі)
    oper_count = [0]                               # створюємо лічильник, ops[0] — присвоєння, ops[1] — порівняння
    start_time = time.perf_counter()           # засікаємо час початку
    mst_weight = 0                             # сюди будемо додавати вагу обраних ребер
    mst_edges = []                             # сюди будемо складати самі ребра, які увійшли в остове дерево

    edges.sort(key=lambda x: x[2])             # сортуємо список ребер за їх вагою у порядку зростання
    num_edges = len(edges)
    if num_edges > 1:
        oper_count[0] += int(num_edges * math.log2(num_edges))

    parent = [0] * n                           # масив батьків, і - відповідає номеру вершини, а parent[i] - вказує на батька цієї вершини
    rank = [0] * n                             # список, де записано висоту підпорядкування, і - відповідає номеру вершини, а rank[і] - скільки рівнів дерева під і-тою вершиною

    # виконуємо стартову ініціалізацію
    for i in range(n):
        parent[i] = i                          # кожна вершина сам собі начальник
        rank[i] = 0                            # кожна вершина не має дітей
        oper_count[0] += 2                            # збільшуємо кількість операцій присвоєння

    # йдемо по вже відсортованому списку, першим беремо ребро з найменшою вагою
    for u, v, w in edges:
        oper_count[0] += 3                            # збільшуємо кількість операцій присвоєння

        if union_sets(parent, rank, u, v, oper_count):# якщо ребро (u, v) не створює цикл і було додане в остов
            mst_weight += w                    # додаємо вагу ребра до загальної суми
            mst_edges.append((u, v, w))        # зберігаємо ребро в список результатів
            oper_count[0] += 2                        # збільшуємо кількість операцій присвоєння

    end_time = time.perf_counter()             # фіксуємо час завершення
    return mst_weight, mst_edges, end_time - start_time, oper_count # повертаємо всі результати

# функція реалізації алгоритму Прима
def algorithm_prim(n, adj_list):      # приймає к-сть вершин та список суміжності, де для кожної вершини записані її сусіди та вага ребер
    oper_count = [0]                      # лічильник операцій, ops[0] - присвоєння, ops[1] - порівняння
    start_time = time.perf_counter()  # засікаємо час початку роботи алгоритму
    mst_weight = 0                    # змінна для суми ваг усіх ребер у знайденому дереві
    mst_edges = []                    # список, куди ми будемо записувати знайдені ребра
    visited = [False] * n             # щоб знати, які вершини ми вже додали до остового дерева
    oper_count[0] += n                       # додаємо до лічильника n операцій присвоєння
    min_heap = [(0, 0, -1)]           # ініціалізуємо мін-купу, починаємо з вершини 0, формат запису в купі: вага, поточна вершина, звідки прийшли
    oper_count[0] += 1                       # збільшуємо лічильник операцій присвоєння

    while min_heap: # цикл працює, доки в купі min_heap є елементи
        oper_count[0] += 1                                          # рахуємо перевірку умови циклу як операцію порівняння

        num_element_minheap = len(min_heap)
        weight, u, prev = heapq.heappop(min_heap)            # дістає з купи елемент із найменшою вагою ребра і видаляє його (перший елемент кортежу)
        oper_count[0] += 3
        if num_element_minheap > 1:
            oper_count[0] += int(math.log2(num_element_minheap))


        oper_count[0] += 1                                          # збільшуємо лічильник операцій порівнянь
        if visited[u]:                                       # перевіряємо, чи ми вже додали вершину u до дерева раніше
            continue                                         # якщо додали то пропускаємо цю вершину

        visited[u] = True                                    # позначаємо вершину u як відвідану
        oper_count[0] += 1                                          # збільшуємо лічильник операцій присвоєння

        oper_count[0] += 1                                          # збільшуємо лічильник операцій порівнянь
        if prev != -1:                                       # перевіряємо, чи це не найперша стартова вершина
            mst_edges.append((prev, u, weight))              # додаємо ребро та вершини в список результатів
            mst_weight += weight                             # додаємо вагу ребра до загальної суми
            oper_count[0] += 2                                      # збільшуємо лічильник операцій присвоєння

        for v, w in adj_list[u]:                             # огляд сусідів нашої вершини
            oper_count[0] += 2                                      # збільшуємо лічильник операцій присвоєння

            oper_count[0] += 1                                      # збільшуємо лічильник операцій порівнянь
            if not visited[v]:                               # якщо сусід v ще не в остовому дереві
                heapq.heappush(min_heap, (w, v, u))     # додаємо цього сусіда в купу як кандидата на наступний крок

                num_element_minheap = len(min_heap)
                if num_element_minheap > 1:
                    oper_count[0] += int(math.log2(num_element_minheap))

    end_time = time.perf_counter()                           # фіксуємо час завершення
    return mst_weight, mst_edges, end_time - start_time, oper_count # повертаємо всі результати

# головна функція програми
def main():
    print("____Програма побудови мінімального остового дерева (Прим vs Крускал)____")

    while True: # цикл повторюватиметься, допоки не буде правильно введено дані
        try: # спробуємо виконати наступний блок коду
            n_str = input("Введіть кількість вершин: ")         # введення к-сті вершин
            m_str = input("Введіть кількість ребер: ")          # введення к-сті ребер
            n = int(n_str)                                      # переводимо з str в int
            m = int(m_str)                                      # переводимо з str в int
            break                                               # якщо успішно перетворено
        except ValueError:                                      # якщо виникла помилка під час введення
            print("Помилка! Введіть коректні числа")            # виведення відповідного повідомлення про помилку

    edges_list = []                      # порожній список для алгоритму Крускала, Крускалу треба просто список усіх ребер, щоб їх відсортувати
    adj_list = [[] for _ in range(n)]    # список для алгоритму Прима, adj_list[0] зберігатиме сусідів вершини 0

    # інструкція що робити користувачу
    print(f"Введіть {m} ребер (формат: звідки, куди, вага ребра). Вершини від 1 до {n}")

    for i in range(m):
        while True: # цикл повторюватиметься, допоки не буде правильно введено дані
            try:    # спробуємо виконати наступний блок коду
                line = input(f"Ребро {i + 1}: ").split()                 # вводимо вершини та ребра (звідки, куди, вага ребра)
                if len(line) != 3:                                       # якщо введено не три значення
                    print("Помилка формату! Потрібно 3 числа")           # виведення відповідного повідомлення
                    continue                                             # починаємо цикл while заново
                u_in, v_in, w = map(int, line)                           # перетворюємо кожен елемент списку на int та зберігаємо дані в окремі змінні

                u = u_in - 1                                             # комп'ютер рахує з 0, тому вершина 1 стає 0 (звідки)
                v = v_in - 1                                             # вершина 2 стає 1 (куди)

                if not (0 <= u < n) or not (0 <= v < n):                 # перевірка меж: чи не ввів користувач вершину 15, коли максимум 10
                    print(f"Помилка! вершини мають бути від 1 до {n}")   # виведення відповідного повідомлення
                    continue                                             # починаємо цикл while заново

                edges_list.append((u, v, w))                             # заповнення даних для Крускала (просто кортеж з 3 чисел)

                # заповнення даних для Прима (додаємо зв'язки в обидві сторони, бо граф неорієнтований)
                adj_list[u].append((v, w))                               # у список сусідів u додаємо v
                adj_list[v].append((u, w))                               # У список сусідів v додаємо u

                break                                                    # якщо дійшли до цього моменту зупиняємо цикл while

            except ValueError:                                           # якщо при введенні ребра ввели літери замість цифр
                print("Помилка! Введіть цілі числа")                     # виведення відповідного повідомлення

    p_weight, p_edges, p_time, p_ops = algorithm_prim(n, adj_list)       # викликаємо функцію алгоритму Прима, вона повертає 4 значення
    p_edges_display = [(u + 1, v + 1, w) for u, v, w in p_edges]         # при виводі результату додамо +1, щоб було красиво

    # виведення результатів алгоритму Прима
    print(f"\n____Алгоритм_Прима____")
    print(f"Отримані ребра:")
    for u, v, w in p_edges_display:
        print(f"       {u}----({w})---->{v}")
    print(f"\nВага ребер: {p_weight}\nЧас: {p_time:.6f} сек\nПрисвоєнь: {p_ops[0]}\nПорівнянь: {p_ops[1]}")

    k_weight, k_edges, k_time, k_ops = algorithm_kruskal(n, edges_list)  # викликаємо функцію алгоритму Крускала, вона повертає 4 значення
    k_edges_display = [(u + 1, v + 1, w) for u, v, w in k_edges]         # при виводі результату додамо +1, щоб було красиво

    # виведення результатів алгоритму Крускала
    print(f"\n____Алгоритм_Крускала____")
    print(f"Отримані ребра:")
    for u, v, w in k_edges_display:
        print(f"       {u}----({w})---->{v}")
    print(f"\nВага ребер: {k_weight}\nЧас: {k_time:.6f} сек\nПрисвоєнь: {k_ops[0]}\nПорівнянь: {k_ops[1]}")

    # виведення результату (який алгоритм виявився швидшим)
    if p_time < k_time:
        print(f"\nАлгоритм Прима швидший на {k_time - p_time:.6f} сек")
    else:
        print(f"\nАлгоритм Крускала швидший на {p_time - k_time:.6f} сек")

main() # виклик головної функції програми
