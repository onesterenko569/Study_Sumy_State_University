#include <stdio.h>
#include <stdlib.h> // підключення бібліотек
#include <time.h>

// структура для зберігання даних про сортування
typedef struct
{
    long comp;                // кількість порівнянь
    long assig;               // кількість присвоєнь
    double time;              // тривалість виконання алгоритму в мілісекундах
} STATS;

// функція для побудови купи 
void heapify(int arr[], int n, int i, STATS* stats)
{
    int largest = i;                                 // зберігатиме індекс елемента з найбільшим значенням
    int left = 2 * i + 1;                            // лівий елемент
    int right = 2 * i + 2;                           // правий елемент

    if (left < n)                                    // якщо не виходимо за межі масиву
    {
        stats->comp++;                               // збільшуємо лічильник порівнянь

        if (arr[left] > arr[largest])                // якщо лівий дочірній елемент більший за корінь
        { 
            largest = left;                          // новим кандидатом на найбільший елемент є лівий нащадок
        }
    }

    if (right < n)                                   // якщо не виходимо за межі масиву
    {
        stats->comp++;                               // збільшуємо лічильник порівнянь

        if (arr[right] > arr[largest])               // якщо правий дочірній елемент більший за корінь
        {
            largest = right;                         // новим кандидатом на найбільший елемент є правий нащадок
        }
    }
    
    if (largest != i)                                // якщо було знайдено елемнт більший за arr[i]
    {
        int temp = arr[i];
        arr[i] = arr[largest];                       // міняємо місцями arr[i] та arr[largest]
        arr[largest] = temp;
        stats->assig += 3;                           // збільшуємо лічильник присвоєнь

        heapify(arr, n, largest, stats);             // рекурсивно будуємо купу для піддерева
    }
}

// основна функція сортування купою
void heap_sort(int arr[], int n, STATS* stats)
{
    stats->comp = 0;                                                     // обнуляємо лічильник порівнянь
    stats->assig = 0;                                                    // обнуляємо лічильник присвоєнь

    clock_t start = clock();                                             // фіксуємо початковий час

    for (int i = n / 2 - 1; i >= 0; i--)                                 // цикл по внутрішнім вузлам
    {
        heapify(arr, n, i, stats);                                       // будуємо купу, де корінь - найбільший елемент
    }

    for (int i = n - 1; i > 0; i--)                                      // цикл по масиву
    {
        int temp = arr[0];                                               // запам'ятовуємо перший елемент масиву
        arr[0] = arr[i];                                                 // переміщуємо останній елемент масиву на початок масиву
        arr[i] = temp;                                                   // останнім елементом записуємо попередній перший, який був найбільшим елементом
        stats->assig += 3;                                               // збільшуємо лічильник присвоєнь

        heapify(arr, i, 0, stats);                                       // викликаємо heapify для зменшеної купи
    }

    clock_t end = clock();                                               // фіксація кінцевого часу
    stats->time = ((double)(end - start) / CLOCKS_PER_SEC) * 1000000;    // обраховуємо час та переводимо в мікросекунди
}


// функція для генерації випадкового, зростаючого та спадаючого масиву
void generate_array(int arr[], int n, int type)
{
    if (type == 0)                     // якщо 0 створюємо випадковий масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = rand() % 10000;   // генеруємо випадковий масив від 0 до 9999
        }
    }
    else if (type == 1)                // якщо 1 створюємо зростаючий масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = i;                // генеруємо масив від 0 до n в порядку зростання
        }
    }
    else                               // якщо 2 створюємо спадний масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = n - i;            // генеруємо масив від n до 0 в порядку спадання
        }
    }
}

// функція перевірки правильності сортування масиву
int is_sorted(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++)   // проходимо по елементах масива
    {
        if (arr[i] > arr[i + 1])      // якщо не відсортовано
        {
            return 0;                 // повертаємо 0 - масив не відсортований
        }
    }
    return 1;                         // повертаємо 1 - масив відсортований
}

// головна функція програми
int main()
{
    srand(time(NULL));                                                       // ініціалізація генератора випадкових чисел

    int sizes[] = { 10, 100, 1000, 5000, 10000 };                            // створюємо масив розмірів
    int num_sizes = sizeof(sizes) / sizeof(sizes[0]);                        // автоматично визначаємо кількість елементів у масиві sizes[] (20 / 4 = 5)

    const char* types[] = { "Vypadkove", "Zrostannya", "Spadannya" };        // масив назв типів послідовностей

    for (int s = 0; s < num_sizes; s++)                                      // зовнішній цикл по розмірах масиву
    {
        int n = sizes[s];                                                    // поточний розмір масиву для цього тесту
        for (int type = 0; type < 3; type++)                                 // внутрішній цикл по типах послідовності
        {
            int* arr = (int*)malloc(n * sizeof(int));                        // динамічно виділяємо пам’ять для масиву arr з n елементів
            if (!arr)                                                        // якщо пам'ять не виділено
            {
                printf("Pomylka vydilennya pam'yati!\n");                    // виведення відповідного повідомлення
                return 1;                                                    // завершуємо програму
            }

            generate_array(arr, n, type);                                    // генерація масиву потрібного типу
            STATS stats;                                                     // cтворення змінної для статистики
            heap_sort(arr, n, &stats);                                       // сортуємо згенерований масив

            if (!is_sorted(arr, n))                                          // якщо відсортовано не правильно
            {
                printf("Masiv ne vidsortovanui!\n");                         // виведення відповідного повідомлення
            }

            printf("N = %-6d %-10s:       Chas vykonannya - %.0f mks       ",
                n, types[type], stats.time);
            printf("Poryvnyannya - %-8ld       Prysvoyennya - %-8ld\n",      // виведення результатів
                stats.comp, stats.assig);

            free(arr);                                                       // звільняємо пам'ять
        }
        printf("\n");                                                        // відступ
    }

    return 0;                                                                // завершення програми
}
