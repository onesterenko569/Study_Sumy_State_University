#include <stdio.h>    // підключаємо стандартну бібліотеку вводу/виводу
#include <stdlib.h>   // підключаємо стандартну бібліотеку загального призначення
#include <limits.h>   // містить визначення граничних значень типів, потрібна для INT_MAX, що означає нескінченність

#define V 5           // кількість вершин у графі

// оголошуємо структуру для вершини
typedef struct Node
{
    int dest;            // індекс вершини, куди веде ребро
    int weight;          // вага цього ребра
    struct Node* next;   // вказівник на наступний вузол у списку (наступного сусіда для нашої вершини)
} Node;

Node* adj[V] = { NULL }; // глобальний масив, який зберігає інформацію про сусідів для кожної і-тої вершини

// функція додає зв'язок між двома вершинам (додає ребро u -> v вагою w)
void addEdge(int u, int v, int w)
{
    Node* newNode = (Node*)malloc(sizeof(Node));    // виділяємо пам'ять
    newNode->dest = v;                              // сусід для u вершини — це v вершина
    newNode->weight = w;                            // вага ребра, яке з'єднує вершини u та v
    newNode->next = adj[u];                         // стара вершина (старий сусід для u) стає наступною
    adj[u] = newNode;                               // новий вузол стає головою списку вершини u (на перше місце)

    // створюємо вузол для ребра v -> u (бо граф неорієнтований)
    newNode = (Node*)malloc(sizeof(Node));          // виділяємо пам'ять
    newNode->dest = u;                              // сусід для v вершини — це u вершина
    newNode->weight = w;                            // вага ребра, яке з'єднує вершини v та u
    newNode->next = adj[v];                         // стара вершина (старий сусід для v) стає наступною
    adj[v] = newNode;                               // новий вузол стає головою списку вершини v (на перше місце)
}

// структура для зберігання пари: "Номер вершини" + "Вага ребра"
// використовується для сортування вершин у черзі з пріоритетом
typedef struct
{
    int vertex;          // номер (індекс) вершини графа
    int key;             // мінімальна вага ребра, яким можна дістатися до цієї вершини з уже побудованої частини дерева
} HeapNode;

// зберігає всю інформацію для керування купою
typedef struct
{
    int size;            // поточний розмір, скільки вершин зараз знаходиться в купі (ще не оброблені)
    int capacity;        // максимальна кількість елементів, яку може помістити купа
    int* pos;            // масив у якому індекс масиву — це номер вершини, а значення в масиві — це індекс у купі
    HeapNode** array;    // масив, де в кожній клітинці лежить і-та адреса на HeapNode (елемент купи), і - індекс елементу в купі
} MinHeap;

// створює один новий об'єкт HeapNode (вузол купи)
HeapNode* newHeapNode(int v, int key)
{
    HeapNode* node = (HeapNode*)malloc(sizeof(HeapNode));   // виділення пам'яті 
    node->vertex = v;                                       // зберігаємо номер (індекс) вершини графа
    node->key = key;                                        // зберігаємо вагу ребра, яким можна дістатися до цієї вершини 
    return node;                                            // повертаємо адресу щойно створеного вузла тому
}

// cтворення мін-купи
MinHeap* createMinHeap(int capacity)
{
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));               // виділяємо в системі пам'ять під головну структуру MinHeap
    heap->pos = (int*)malloc(V * sizeof(int));                       // виділяємо пам'ять під масив цілих чисел
    heap->size = 0;                                                  // записуємо що купа поки порожня
    heap->capacity = capacity;                                       // записуємо максимальну кількість елементів, яку може помістити купа 
    heap->array = (HeapNode**)malloc(capacity * sizeof(HeapNode*));  // виділяємо масив, який буде зберігати адреси (вказівники) на вузли HeapNode
    return heap;                                                     // повертаємо адресу цього налаштованого пульта керування купою
}

// обмін вузлів купи
void swapHeapNode(HeapNode** a, HeapNode** b)
{
    HeapNode* t = *a;     // зберігаємо значення а в тимчасове сховище
    *a = *b;              // перезаписуємо a значенням b
    *b = t;               // відновлюємо значення з t в b
}

// просіювання вниз, відновлює правильну структуру Мін-Купи, якщо порядок порушено
void minHeapify(MinHeap* heap, int idx)
{
    int smallest = idx;                                             // припускаємо, що поточний елемент (батько) найменший
    int left = 2 * idx + 1;                                         // формула індексу лівої дитини
    int right = 2 * idx + 2;                                        // формула індексу правої дитини

    if (left < heap->size && heap->array[left]->key < heap->array[smallest]->key)    // якщо ліва дитина має меншу вагу за батька
    {
        smallest = left;                                                             // ліва дитина стає претендентом на підняття вгору
    }

    if (right < heap->size && heap->array[right]->key < heap->array[smallest]->key)  // якщо права дитина має меншу вагу за батька
    {
        smallest = right;                                                            // права дитина стає претендентом на підняття вгору                                     
    }

    if (smallest != idx)                                 // якщо один з дітей менший за батька міняємо місцями
    {
        heap->pos[heap->array[smallest]->vertex] = idx;  // вершина, яка була на місці дитини (smallest), тепер переїжджає на місце батька (idx)
        heap->pos[heap->array[idx]->vertex] = smallest;  // вершина - батько переїжджає на місце дитини

        swapHeapNode(&heap->array[smallest], &heap->array[idx]); // міняємо місцями вказівники в масиві array
        minHeapify(heap, smallest);                              // рекурсія
    }
}

// витягування мінімального елемента з купи
HeapNode* extractMin(MinHeap* heap)
{
    if (heap->size == 0)                                 // перевіряємо чи порожня купа
    {
        return NULL;                                     // якщо купа порожня, повертаємо NULL (захист від помилки)
    }

    HeapNode* root = heap->array[0];                     // зберігаємо посилання на найменший елемент Мін-Купи
    HeapNode* lastNode = heap->array[heap->size - 1];    // зберігаємо посилання на останній елемент Мін-Купи (з великою вагою)

    heap->array[0] = lastNode;                           // ставимо останній елемент (lastNode) на перше місце

    heap->pos[root->vertex] = heap->size - 1;            // ставимо найменший елемент (який витягнули) у кінець купи
    heap->pos[lastNode->vertex] = 0;                     // записуємо, що той елемент, який був останнім, тепер сидить під індексом 0

    heap->size--;                                        // зменшуємо розмір купи на 1, внаслідок чого останній елемент (витягнутий) видаляється
    minHeapify(heap, 0);                                 // відновлюємо правильну структуру Мін - Купи, оскільки порядок порушено

    return root;                                         // повертаємо збережений на початку мінімальний вузол
}

// оновлює значення вершини (зменшує вагу) і піднімає її вгору, щоб відновити порядок купи
void decreaseKey(MinHeap* heap, int v, int key)
{
    int i = heap->pos[v];        // отримаємо порядковий номер (індекс) під яким знаходиться вершина в купі
    heap->array[i]->key = key;   // перезаписуємо стару вагу на нову, меншу

    while (i && heap->array[i]->key < heap->array[(i - 1) / 2]->key) // якщо дочірній елемент легший за батька та і != 0
    {
        heap->pos[heap->array[i]->vertex] = (i - 1) / 2;    // міняємо позицію в купі (син <--> батько)
        heap->pos[heap->array[(i - 1) / 2]->vertex] = i;    // міняємо позицію в купі (батько <--> син)

        swapHeapNode(&heap->array[i], &heap->array[(i - 1) / 2]); // міняємо місцями вказівники в основному масиві

        i = (i - 1) / 2;                                          // підготовка до наступного кроку
    }
}

// перевіряємо чи є вершина в купі
int isInMinHeap(MinHeap* heap, int v)
{
    if (heap->pos[v] < heap->size)  // перевіряємо чи знаходиться вершина в купі
    {
        return 1;  // повертаємо 1 (True)
    }

    return 0;      // повертаємо 0 (False)
}

// реалізація алгоритму Прима
void primMST()
{
    int parent[V];  // масив зв'язків (індекс масиву (i) — це вершина-дитина (куди ми прийшли), а значення масиву (parent[i]) — це вершина-батько (звідки ми прийшли))
    int key[V];     // масив у який записуємо найлегше ребро для приєднання кожної вершини (індекс масиву (і) - вершина до якої веде ребро, а значення масиву - вага ребра)

    MinHeap* heap = createMinHeap(V);            // cтворюємо порожню мін-купу

    // ініціалізація (скидання налаштувань) купи
    for (int v = 0; v < V; v++)
    {
        parent[v] = -1;                          // спочатку ніхто ні до кого не приєднаний
        key[v] = INT_MAX;                        // робимо вагу ребер максимальною
        heap->array[v] = newHeapNode(v, key[v]); // створюємо вузол для купи
        heap->pos[v] = v;                        // спочатку вершина 0 лежить в комірці 0, 1 в 1 і т.д.
    }

    key[0] = 0;                                  // починаємо з вершини 0, вага ребра до неї = 0
    heap->array[0]->key = 0;                     // оновлюємо це в купі
    heap->size = V;                              // встановлюємо, що в купі зараз V вершин (усі активні)

    // цикл працює, доки купа не спорожніє (доки ми не приєднаємо всі вершини)
    while (heap->size > 0)
    {
        HeapNode* minNode = extractMin(heap);                  // дістаємо вершину з найменшим ребром (спочатку це буде 0)
        int u = minNode->vertex;                               // u — це вершина, яку ми щойно додали до мінімального остового дерева

        Node* temp = adj[u];                                   // беремо список сусідів вершини u

        while (temp != NULL)                                   // проходимо по всіх сусідах
        {
            int v = temp->dest;                                // v — це сусід, на якого ми дивимось

            if (isInMinHeap(heap, v) && temp->weight < key[v]) // якщо сусід v ще не в дереві (є в купі) та ми знайшли коротший шлях до нього
            {
                key[v] = temp->weight;           // оновлюємо вагу ребра що веде до v
                parent[v] = u;                   // запам'ятовуємо, що найкраще йти до v від u
                decreaseKey(heap, v, key[v]);    // оновлюємо пріоритет у купі (v спливає вгору)
            }
            temp = temp->next;                   // переходимо до наступного сусіда
        }
    }

    // виведення результатів
    printf("Rebra minimalnoho ostovoho dereva:\n");
    int sum = 0;                                               // зберігатиме сумарну вагу найменших ребер             
    for (int i = 1; i < V; i++)                                // починаємо з 1, бо у вершини 0 немає батька (вона корінь)
    {
        printf("%d - %d (vaha %d)\n", parent[i], i, key[i]);   // виведення результатів
        sum += key[i];                                         // обраховуємо вагу ребер
    }
    printf("Sumarna vaha = %d\n", sum);                        // виведення результатів
}

int main() // головна функція програми
{
    // будуємо граф
    addEdge(0, 1, 2);
    addEdge(0, 2, 3);
    addEdge(1, 2, 1);
    addEdge(1, 3, 4);
    addEdge(2, 3, 5);
    addEdge(2, 4, 6);
    addEdge(3, 4, 7);

    primMST(); // викликаємо функцію яка знайде мінімальне остове дерево

    return 0;
}