#include <stdio.h>
#include <stdlib.h> // підключення бібліотек
#include <time.h>

// структура для зберігання даних про сортування
typedef struct
{
    long comp;                // кількість порівнянь
    long assig;               // кількість присвоєнь
    double time;              // тривалість виконання алгоритму в мілісекундах
} STATS;

// злиття двох частин масиву
void merge(int arr[], int left, int mid, int right, STATS* stats)
{
    int n1 = mid - left + 1;                    // обчислюємо кількість елементів у лівому масиві
    int n2 = right - mid;                       // обчислюємо кількість елементів у правому масиві

    int* L = (int*)malloc(n1 * sizeof(int));    // виділяємо пам'ять для копії лівого масиву
    int* R = (int*)malloc(n2 * sizeof(int));    // виділяємо пам'ять для копії правого масиву

    for (int i = 0; i < n1; i++)                // копіюємо дані з лівої частини основного масиву до масиву L[]
    { 
        L[i] = arr[left + i];                   // копіювання даних
        stats->assig++;                         // збільшуємо кількість операцій присвоєння
    } 

    for (int j = 0; j < n2; j++)                // копіюємо дані з правої частини основного масиву до масиву R[]
    { 
        R[j] = arr[mid + 1 + j];                // копіювання даних
        stats->assig++;                         // збільшуємо кількість операцій присвоєння
    }

    int i = 0, j = 0, k = left;                 // оголошуємо необхідні дані

    while (i < n1 && j < n2)                    // поки не дійшли до останніх елементів лівої та правої частини масиву
    {
        stats->comp++;                          // збільшуємо кількість операцій порівнянь

        if (L[i] <= R[j])                       // якщо елемент з лівої частини <= елементу з правої частини
        {
            arr[k++] = L[i++];                  // вставляємо менший елемент у основний масив
            stats->assig++;                     // збільшуємо кількість операцій присвоєння
        }

        else                                    // якщо елемент з лівої частини > за елемент з правої частини
        {
            arr[k++] = R[j++];                  // вставляємо менший елемент у основний масив
            stats->assig++;                     // збільшуємо кількість операцій присвоєння
        }
    }

    while (i < n1)                              // якщо в L[] ще залишилися елементи
    { 
        arr[k++] = L[i++];                      // копіюємо їх у arr[]
        stats->assig++;                         // збільшуємо кількість операцій присвоєння
    }

    while (j < n2)                              // якщо в R[] ще залишилися елементи
    { 
        arr[k++] = R[j++];                      // копіюємо їх у arr[]
        stats->assig++;                         // збільшуємо кількість операцій присвоєння
    }

    free(L);                                    // звільнення пам'яті 
    free(R);                                    // звільнення пам'яті 
}

// рекурсивна функція сортування злиттям
void merge_sort_recursive(int arr[], int left, int right, STATS* stats)
{
    if (left < right)                                     // перевірка чи масив існує
    {
        int mid = left + (right - left) / 2;              // обчислюємо середину поточного фрагмента масиву
        merge_sort_recursive(arr, left, mid, stats);      // рекурсивно сортуємо ліву половину
        merge_sort_recursive(arr, mid + 1, right, stats); // рекурсивно сортуємо праву половину
        merge(arr, left, mid, right, stats);              // зливаємо відсортовані половини у відсортований масив
    }
}

// головна функція сортування злиттям
void merge_sort(int arr[], int n, STATS* stats)
{
    stats->comp = 0;                                                 // обнуляємо лічильник порівнянь
    stats->assig = 0;                                                // обнуляємо лічильник присвоєнь

    clock_t start = clock();                                         // запам’ятовуємо початковий час виконання алгоритму

    merge_sort_recursive(arr, 0, n - 1, stats);                      // викликаємо функцію для сортування                 

    clock_t end = clock();                                           // запам’ятовуємо кінець виконання алгоритму
    stats->time = ((double)(end - start) / CLOCKS_PER_SEC) * 1000000;// обраховуємо час та переводимо в мікросекунди
}

// функція для генерації випадкового, зростаючого та спадаючого масиву
void generate_array(int arr[], int n, int type)
{
    if (type == 0)                     // якщо 0 створюємо випадковий масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = rand() % 10000;   // генеруємо випадковий масив від 0 до 9999
        }
    }
    else if (type == 1)                // якщо 1 створюємо зростаючий масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = i;                // генеруємо масив від 0 до n в порядку зростання
        }
    }
    else                               // якщо 2 створюємо спадний масив
    {
        for (int i = 0; i < n; i++)    // цикл для генерації масиву
        {
            arr[i] = n - i;            // генеруємо масив від n до 0 в порядку спадання
        }
    }
}

// функція перевірки правильності сортування масиву
int is_sorted(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++)   // проходимо по елементах масива
    {
        if (arr[i] > arr[i + 1])      // якщо не відсортовано
        {
            return 0;                 // повертаємо 0 - масив не відсортований
        }
    }
    return 1;                         // повертаємо 1 - масив відсортований
}

// головна функція програми
int main()
{
    srand(time(NULL));                                                       // ініціалізація генератора випадкових чисел

    int sizes[] = { 10, 100, 1000, 5000, 10000 };                            // створюємо масив розмірів
    int num_sizes = sizeof(sizes) / sizeof(sizes[0]);                        // автоматично визначаємо кількість елементів у масиві sizes[] (20 / 4 = 5)

    const char* types[] = { "Vypadkove", "Zrostannya", "Spadannya" };        // масив назв типів послідовностей

    for (int s = 0; s < num_sizes; s++)                                      // зовнішній цикл по розмірах масиву
    {
        int n = sizes[s];                                                    // поточний розмір масиву для цього тесту
        for (int type = 0; type < 3; type++)                                 // внутрішній цикл по типах послідовності
        {
            int* arr = (int*)malloc(n * sizeof(int));                        // динамічно виділяємо пам’ять для масиву arr з n елементів
            if (!arr)                                                        // якщо пам'ять не виділено
            {
                printf("Pomylka vydilennya pam'yati!\n");                    // виведення відповідного повідомлення
                return 1;                                                    // завершуємо програму
            }

            generate_array(arr, n, type);                                    // генерація масиву потрібного типу
            STATS stats;                                                     // cтворення змінної для статистики
            merge_sort(arr, n, &stats);                                      // сортуємо згенерований масив

            if (!is_sorted(arr, n))                                          // якщо відсортовано не правильно
            {
                printf("Masiv ne vidsortovanui!\n");                         // виведення відповідного повідомлення
            }

            printf("N = %-6d %-10s:       Chas vykonannya - %.0f mks       ",
                n, types[type], stats.time);
            printf("Poryvnyannya - %-8ld       Prysvoyennya - %-8ld\n",      // виведення результатів
                stats.comp, stats.assig);

            free(arr);                                                       // звільняємо пам'ять
        }
        printf("\n");                                                        // відступ
    }

    return 0;                                                                // завершення програми
}